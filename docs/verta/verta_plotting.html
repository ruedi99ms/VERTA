<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>verta.verta_plotting API documentation</title>
<meta name="description" content="VERTA Plotting Module …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>verta.verta_plotting</code></h1>
</header>
<section id="section-intro">
<p>VERTA Plotting Module</p>
<p>This module provides plotting functions for trajectory analysis and visualization.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="verta.verta_plotting.plot_chain_overview"><code class="name flex">
<span>def <span class="ident">plot_chain_overview</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>],<br>chain_df: pandas.core.frame.DataFrame,<br>junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>],<br>r_outer_list: List[float] | None = None,<br>path_length: float = 100.0,<br>epsilon: float = 0.015,<br>linger_delta: float = 5.0,<br>decision_mode: str = 'hybrid',<br>out_path: str = 'Chain_Overview.png',<br>show_paths: bool = True,<br>show_centers: bool = False,<br>centers_list: List[numpy.ndarray] | None = None,<br>annotate_counts: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_chain_overview(trajectories: List[Trajectory], chain_df: pd.DataFrame, junctions: List[Circle], 
                       r_outer_list: Optional[List[float]] = None, path_length: float = 100.0, 
                       epsilon: float = 0.015, linger_delta: float = 5.0, decision_mode: str = &#34;hybrid&#34;,
                       out_path: str = &#34;Chain_Overview.png&#34;, show_paths: bool = True, 
                       show_centers: bool = False, centers_list: Optional[List[np.ndarray]] = None,
                       annotate_counts: bool = False):
    &#34;&#34;&#34;
    Plot an overview of the decision chain analysis showing all junctions and trajectories.
    
    Args:
        trajectories: List of trajectory objects
        chain_df: DataFrame with chain analysis results
        junctions: List of junction Circle objects
        r_outer_list: Optional list of outer radii for each junction
        path_length: Path length for decision analysis
        epsilon: Minimum step size
        linger_delta: Linger distance beyond junction
        decision_mode: Decision mode (&#34;pathlen&#34;, &#34;radial&#34;, &#34;hybrid&#34;)
        out_path: Output file path
        show_paths: Whether to show trajectory paths
        show_centers: Whether to show branch centers
        centers_list: Optional list of branch centers for each junction
        annotate_counts: Whether to annotate branch counts
    &#34;&#34;&#34;
    fig, ax = plt.subplots(figsize=DEFAULT_PLOT_CONFIG.figsize, dpi=DEFAULT_PLOT_CONFIG.dpi)
    
    # Plot trajectories
    if show_paths:
        for traj in trajectories:
            ax.plot(traj.x, traj.z, &#39;b-&#39;, alpha=0.3, linewidth=0.5)
    
    # Plot junctions
    for i, junction in enumerate(junctions):
        # Main junction circle
        circle = plt.Circle((junction.cx, junction.cz), junction.r, 
                          color=&#39;red&#39;, alpha=0.3, edgecolor=&#39;red&#39;, linewidth=2)
        ax.add_patch(circle)
        
        # Outer radius if available
        if r_outer_list and i &lt; len(r_outer_list) and r_outer_list[i] is not None:
            outer_circle = plt.Circle((junction.cx, junction.cz), r_outer_list[i], 
                                    color=&#39;red&#39;, alpha=0.1, edgecolor=&#39;red&#39;, linewidth=1, linestyle=&#39;--&#39;)
            ax.add_patch(outer_circle)
        
        # Junction label
        ax.text(junction.cx, junction.cz, f&#39;J{i}&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, 
                fontsize=DEFAULT_PLOT_CONFIG.fontsize, fontweight=&#39;bold&#39;, color=&#39;red&#39;)
    
    # Plot branch centers if available
    if show_centers and centers_list:
        for i, centers in enumerate(centers_list):
            if centers is not None and len(centers) &gt; 0:
                junction = junctions[i]
                for j, center in enumerate(centers):
                    ax.plot(center[0], center[1], &#39;o&#39;, color=DEFAULT_PLOT_CONFIG.get_branch_color(j), 
                           markersize=8, markeredgecolor=&#39;black&#39;, markeredgewidth=1)
                    if annotate_counts:
                        ax.text(center[0], center[1], f&#39;B{j}&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, 
                               fontsize=8, fontweight=&#39;bold&#39;)
    
    ax.set_xlabel(&#39;X Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
    ax.set_ylabel(&#39;Z Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
    ax.set_title(&#39;Decision Chain Overview&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize)
    ax.grid(True, alpha=DEFAULT_PLOT_CONFIG.grid_alpha)
    ax.set_aspect(&#39;equal&#39;)
    
    DEFAULT_PLOT_CONFIG.apply_to_figure(fig)
    plt.savefig(out_path, dpi=DEFAULT_PLOT_CONFIG.dpi, bbox_inches=&#39;tight&#39;)
    plt.close()</code></pre>
</details>
<div class="desc"><p>Plot an overview of the decision chain analysis showing all junctions and trajectories.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with chain analysis results</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of junction Circle objects</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>Optional list of outer radii for each junction</dd>
<dt><strong><code>path_length</code></strong></dt>
<dd>Path length for decision analysis</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Minimum step size</dd>
<dt><strong><code>linger_delta</code></strong></dt>
<dd>Linger distance beyond junction</dd>
<dt><strong><code>decision_mode</code></strong></dt>
<dd>Decision mode ("pathlen", "radial", "hybrid")</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Output file path</dd>
<dt><strong><code>show_paths</code></strong></dt>
<dd>Whether to show trajectory paths</dd>
<dt><strong><code>show_centers</code></strong></dt>
<dd>Whether to show branch centers</dd>
<dt><strong><code>centers_list</code></strong></dt>
<dd>Optional list of branch centers for each junction</dd>
<dt><strong><code>annotate_counts</code></strong></dt>
<dd>Whether to annotate branch counts</dd>
</dl></div>
</dd>
<dt id="verta.verta_plotting.plot_chain_small_multiples"><code class="name flex">
<span>def <span class="ident">plot_chain_small_multiples</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>],<br>chain_df: pandas.core.frame.DataFrame,<br>junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>],<br>r_outer_list: List[float] | None = None,<br>window_radius: float = 80.0,<br>path_length: float = 100.0,<br>epsilon: float = 0.015,<br>linger_delta: float = 5.0,<br>decision_mode: str = 'hybrid',<br>out_path: str = 'Chain_SmallMultiples.png',<br>centers_list: List[numpy.ndarray] | None = None,<br>decisions_df: pandas.core.frame.DataFrame | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_chain_small_multiples(trajectories: List[Trajectory], chain_df: pd.DataFrame, junctions: List[Circle],
                              r_outer_list: Optional[List[float]] = None, window_radius: float = 80.0,
                              path_length: float = 100.0, epsilon: float = 0.015, linger_delta: float = 5.0,
                              decision_mode: str = &#34;hybrid&#34;, out_path: str = &#34;Chain_SmallMultiples.png&#34;,
                              centers_list: Optional[List[np.ndarray]] = None, decisions_df: Optional[pd.DataFrame] = None):
    &#34;&#34;&#34;
    Plot small multiples showing trajectory patterns around each junction with branch coloring and intercepts.
    
    Args:
        trajectories: List of trajectory objects
        chain_df: DataFrame with chain analysis results
        junctions: List of junction Circle objects
        r_outer_list: Optional list of outer radii for each junction
        window_radius: Radius of the window around each junction
        path_length: Path length for decision analysis
        epsilon: Minimum step size
        linger_delta: Linger distance beyond junction
        decision_mode: Decision mode (&#34;pathlen&#34;, &#34;radial&#34;, &#34;hybrid&#34;)
        out_path: Output file path
        centers_list: Optional list of branch centers for each junction
        decisions_df: DataFrame with decision points (intercept_x, intercept_z, trajectory, junction_idx)
    &#34;&#34;&#34;
    n_junctions = len(junctions)
    if n_junctions == 0:
        return
    
    # Debug: Print chain_df info
    print(f&#34;DEBUG: chain_df shape: {chain_df.shape}&#34;)
    print(f&#34;DEBUG: chain_df columns: {list(chain_df.columns)}&#34;)
    print(f&#34;DEBUG: centers_list length: {len(centers_list) if centers_list else &#39;None&#39;}&#34;)
    
    # Calculate grid layout
    cols = min(3, n_junctions)  # Max 3 columns
    rows = (n_junctions + cols - 1) // cols
    
    fig, axes = plt.subplots(rows, cols, figsize=(cols * 6, rows * 6), dpi=DEFAULT_PLOT_CONFIG.dpi)
    if n_junctions == 1:
        axes = [axes]
    elif rows == 1:
        axes = axes if isinstance(axes, list) else [axes]
    else:
        axes = axes.flatten()
    
    for i, junction in enumerate(junctions):
        ax = axes[i] if i &lt; len(axes) else None
        if ax is None:
            continue
            
        # Set window bounds
        x_min, x_max = junction.cx - window_radius, junction.cx + window_radius
        z_min, z_max = junction.cz - window_radius, junction.cz + window_radius
        
        # Get branch assignments for this junction
        branch_col = f&#34;branch_j{i}&#34;
        print(f&#34;DEBUG: Looking for column &#39;{branch_col}&#39; in chain_df&#34;)
        
        if branch_col in chain_df.columns:
            print(f&#34;DEBUG: Found column &#39;{branch_col}&#39;, unique values: {chain_df[branch_col].unique()}&#34;)
            
            # Create trajectory to branch mapping
            traj_branches = {}
            for _, row in chain_df.iterrows():
                traj_id = row.get(&#39;trajectory&#39;, 0)
                branch = row.get(branch_col)
                if pd.notna(branch) and branch &gt;= 0:  # Only valid branches
                    traj_branches[traj_id] = int(branch)
            
            print(f&#34;DEBUG: Junction {i} - traj_branches: {len(traj_branches)} trajectories assigned&#34;)
            
            # Plot trajectories colored by branch
            branch_colors = {}
            for traj_idx, traj in enumerate(trajectories):
                branch = traj_branches.get(traj_idx, -1)
                if branch &gt;= 0:  # Valid branch
                    if branch not in branch_colors:
                        branch_colors[branch] = DEFAULT_PLOT_CONFIG.get_branch_color(branch)
                    
                    # Filter trajectory points within window
                    mask = ((traj.x &gt;= x_min) &amp; (traj.x &lt;= x_max) &amp; 
                           (traj.z &gt;= z_min) &amp; (traj.z &lt;= z_max))
                    if np.any(mask):
                        ax.plot(traj.x[mask], traj.z[mask], color=branch_colors[branch], 
                               alpha=0.6, linewidth=1)
            
            print(f&#34;DEBUG: Junction {i} - branch_colors: {branch_colors}&#34;)
            
            # Plot decision intercepts using the same logic as plot_decision_intercepts
            if centers_list and i &lt; len(centers_list) and centers_list[i] is not None:
                centers = centers_list[i]
                r_outer = r_outer_list[i] if r_outer_list and i &lt; len(r_outer_list) else junction.r * 2
                
                print(f&#34;DEBUG: Junction {i} - centers shape: {centers.shape if hasattr(centers, &#39;shape&#39;) else &#39;No shape&#39;}&#34;)
                print(f&#34;DEBUG: Junction {i} - r_outer: {r_outer}&#34;)
                
                # Create assignments DataFrame for this junction
                junction_assignments = chain_df[[&#39;trajectory&#39;, branch_col]].copy()
                junction_assignments = junction_assignments.rename(columns={branch_col: &#39;branch&#39;})
                junction_assignments = junction_assignments[junction_assignments[&#39;branch&#39;] &gt;= 0]
                
                print(f&#34;DEBUG: Junction {i} - junction_assignments shape: {junction_assignments.shape}&#34;)
                
                if len(junction_assignments) &gt; 0:
                    # Plot decision intercepts for each branch
                    for branch_idx, center in enumerate(centers):
                        if branch_idx in branch_colors:
                            color = branch_colors[branch_idx]
                            
                            # Get trajectories for this branch
                            branch_trajectories = junction_assignments[junction_assignments[&#39;branch&#39;] == branch_idx]
                            
                            print(f&#34;DEBUG: Junction {i}, Branch {branch_idx} - {len(branch_trajectories)} trajectories&#34;)
                            
                            # For each trajectory in this branch, find where it intersects the outer radius
                            for _, row in branch_trajectories.iterrows():
                                traj_id = row[&#39;trajectory&#39;]
                                if traj_id &lt; len(trajectories):
                                    traj = trajectories[traj_id]
                                    
                                    # Find intersection with outer radius circle
                                    # Calculate distance from junction center for each point
                                    distances = np.sqrt((traj.x - junction.cx)**2 + (traj.z - junction.cz)**2)
                                    
                                    # Find points near the outer radius
                                    radius_tolerance = 5.0  # Tolerance for intersection detection
                                    near_radius = np.abs(distances - r_outer) &lt; radius_tolerance
                                    
                                    if np.any(near_radius):
                                        # Get the first point that&#39;s near the outer radius
                                        intersect_idx = np.where(near_radius)[0][0]
                                        intersect_x = traj.x[intersect_idx]
                                        intersect_z = traj.z[intersect_idx]
                                        
                                        # Only plot if within window
                                        if (x_min &lt;= intersect_x &lt;= x_max and z_min &lt;= intersect_z &lt;= z_max):
                                            ax.plot(intersect_x, intersect_z, &#39;o&#39;, color=color, 
                                                   markersize=4, markeredgecolor=&#39;black&#39;, markeredgewidth=0.5)
            else:
                print(f&#34;DEBUG: Junction {i} - No centers_list or centers is None&#34;)
            
            # Create legend for branches
            if branch_colors:
                legend_elements = []
                for branch in sorted(branch_colors.keys()):
                    legend_elements.append(plt.Line2D([0], [0], color=branch_colors[branch], 
                                                    label=f&#39;Branch {branch}&#39;))
                ax.legend(handles=legend_elements, loc=&#39;upper right&#39;, fontsize=8)
        else:
            print(f&#34;DEBUG: Column &#39;{branch_col}&#39; not found in chain_df&#34;)
            # Fallback: plot all trajectories in blue if no branch data
            for traj in trajectories:
                mask = ((traj.x &gt;= x_min) &amp; (traj.x &lt;= x_max) &amp; 
                       (traj.z &gt;= z_min) &amp; (traj.z &lt;= z_max))
                if np.any(mask):
                    ax.plot(traj.x[mask], traj.z[mask], &#39;b-&#39;, alpha=0.6, linewidth=1)
        
        # Plot junction
        circle = plt.Circle((junction.cx, junction.cz), junction.r, 
                          color=&#39;black&#39;, alpha=0.8, edgecolor=&#39;black&#39;, linewidth=2)
        ax.add_patch(circle)
        
        # Plot outer radius if available
        if r_outer_list and i &lt; len(r_outer_list) and r_outer_list[i] is not None:
            outer_circle = plt.Circle((junction.cx, junction.cz), r_outer_list[i], 
                                    color=&#39;orange&#39;, alpha=0.3, edgecolor=&#39;orange&#39;, linewidth=2)
            ax.add_patch(outer_circle)
        
        # Add junction center dot
        ax.plot(junction.cx, junction.cz, &#39;ko&#39;, markersize=3)
        
        # Count intercepts for title
        intercept_count = 0
        if branch_col in chain_df.columns:
            intercept_count = len(chain_df[chain_df[branch_col] &gt;= 0])
        
        # Set axis properties
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(z_min, z_max)
        ax.set_xlabel(&#39;X Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
        ax.set_ylabel(&#39;Z Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
        ax.set_title(f&#39;J{i} ({intercept_count} intercepts)&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize)
        ax.grid(True, alpha=DEFAULT_PLOT_CONFIG.grid_alpha)
        ax.set_aspect(&#39;equal&#39;)
    
    # Hide unused subplots
    for i in range(n_junctions, len(axes)):
        axes[i].set_visible(False)
    
    plt.suptitle(&#39;Decision Chain Small Multiples&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize + 2)
    DEFAULT_PLOT_CONFIG.apply_to_figure(fig)
    plt.savefig(out_path, dpi=DEFAULT_PLOT_CONFIG.dpi, bbox_inches=&#39;tight&#39;)
    plt.close()</code></pre>
</details>
<div class="desc"><p>Plot small multiples showing trajectory patterns around each junction with branch coloring and intercepts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with chain analysis results</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of junction Circle objects</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>Optional list of outer radii for each junction</dd>
<dt><strong><code>window_radius</code></strong></dt>
<dd>Radius of the window around each junction</dd>
<dt><strong><code>path_length</code></strong></dt>
<dd>Path length for decision analysis</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Minimum step size</dd>
<dt><strong><code>linger_delta</code></strong></dt>
<dd>Linger distance beyond junction</dd>
<dt><strong><code>decision_mode</code></strong></dt>
<dd>Decision mode ("pathlen", "radial", "hybrid")</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Output file path</dd>
<dt><strong><code>centers_list</code></strong></dt>
<dd>Optional list of branch centers for each junction</dd>
<dt><strong><code>decisions_df</code></strong></dt>
<dd>DataFrame with decision points (intercept_x, intercept_z, trajectory, junction_idx)</dd>
</dl></div>
</dd>
<dt id="verta.verta_plotting.plot_decision_intercepts"><code class="name flex">
<span>def <span class="ident">plot_decision_intercepts</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>],<br>assignments_df: pandas.core.frame.DataFrame,<br>mode_log_df: pandas.core.frame.DataFrame,<br>centers: numpy.ndarray,<br>junction: <a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>,<br>r_outer: float,<br>path_length: float,<br>epsilon: float,<br>linger_delta: float,<br>*,<br>out_path: str = 'Decision_Intercepts.png',<br>show_paths: bool = True,<br>legend_noenter_as_line: bool = False,<br>junction_number: int = 0,<br>all_junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>] = None,<br>decision_points_df: pandas.core.frame.DataFrame = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_decision_intercepts(
    trajectories: List[Trajectory],
    assignments_df: pd.DataFrame,
    mode_log_df: pd.DataFrame,
    centers: np.ndarray,
    junction: Circle,
    r_outer: float,
    path_length: float,
    epsilon: float,
    linger_delta: float,
    *,
    out_path: str = &#34;Decision_Intercepts.png&#34;,
    show_paths: bool = True,
    legend_noenter_as_line: bool = False,
    junction_number: int = 0,
    all_junctions: List[Circle] = None,
    decision_points_df: pd.DataFrame = None
) -&gt; None:
    &#34;&#34;&#34;Plot decision intercepts for a junction with branch analysis.
    
    Args:
        trajectories: List of Trajectory objects
        assignments_df: DataFrame with trajectory assignments
        mode_log_df: DataFrame with mode information
        centers: Array of cluster centers
        junction: Junction circle
        r_outer: Outer radius for analysis
        path_length: Path length threshold
        epsilon: Epsilon parameter
        linger_delta: Linger delta parameter
        out_path: Output path for the plot
        show_paths: Whether to show trajectory paths
        legend_noenter_as_line: Whether to show no-entry as line in legend
        junction_number: Junction number for title
        all_junctions: List of all junctions for mini-map
        decision_points_df: DataFrame with actual decision point coordinates
    &#34;&#34;&#34;
    # Create a more comprehensive layout with heading and mini-map
    fig = plt.figure(figsize=(16, 12))
    
    # Create a grid layout: heading at top, main plot in center, mini-map at bottom
    gs = fig.add_gridspec(3, 1, height_ratios=[0.5, 3, 1], hspace=0.3)
    
    # Add heading
    ax_title = fig.add_subplot(gs[0])
    ax_title.text(0.5, 0.5, f&#39;Junction {junction_number} - Decision Intercepts Analysis&#39;, 
                  ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=16, fontweight=&#39;bold&#39;)
    ax_title.set_xlim(0, 1)
    ax_title.set_ylim(0, 1)
    ax_title.axis(&#39;off&#39;)
    
    # Main plot
    ax = fig.add_subplot(gs[1])
    
    # Plot trajectories if requested
    if show_paths:
        for tr in trajectories:
            ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.5, alpha=0.3)
    
    # Plot junction
    theta = np.linspace(0, 2*np.pi, 100)
    junction_x = junction.cx + junction.r * np.cos(theta)
    junction_z = junction.cz + junction.r * np.sin(theta)
    ax.plot(junction_x, junction_z, &#39;k-&#39;, linewidth=2, label=&#39;Junction&#39;)
    
    # Plot outer radius
    outer_x = junction.cx + r_outer * np.cos(theta)
    outer_z = junction.cz + r_outer * np.sin(theta)
    ax.plot(outer_x, outer_z, &#39;orange&#39;, linewidth=1, alpha=0.7, label=&#39;Analysis Radius&#39;)
    
    # Plot junction center
    ax.scatter([junction.cx], [junction.cz], c=&#39;black&#39;, s=50, marker=&#39;o&#39;, 
              label=&#39;Junction Center&#39;)
    
    # Plot branch analysis with triangular markers and connections
    if len(centers) &gt; 0 and assignments_df is not None:
        # Define colors and markers for different branches
        colors = [&#39;blue&#39;, &#39;orange&#39;, &#39;green&#39;, &#39;red&#39;, &#39;purple&#39;, &#39;brown&#39;, &#39;pink&#39;, &#39;gray&#39;]
        markers = [&#39;^&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;v&#39;, &#39;s&#39;, &#39;D&#39;, &#39;o&#39;, &#39;h&#39;]
        
        # Calculate branch statistics
        branch_counts = assignments_df[&#39;branch&#39;].value_counts().sort_index()
        total_trajectories = len(assignments_df)
        
        # Plot branch markers and directions
        for i, center in enumerate(centers):
            color = colors[i % len(colors)]
            marker = markers[i % len(markers)]
            
            # Get assignments for this branch
            branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
            branch_count = len(branch_assignments)
            
            if branch_count &gt; 0:
                # Calculate branch direction from actual decision points if available
                if decision_points_df is not None and len(decision_points_df) &gt; 0:
                    # Merge decision points with assignments to get actual coordinates
                    assignments_df_copy = assignments_df.copy()
                    decision_points_df_copy = decision_points_df.copy()
                    
                    # Convert trajectory columns to string to ensure compatibility
                    if &#39;trajectory&#39; in assignments_df_copy.columns:
                        assignments_df_copy[&#39;trajectory&#39;] = assignments_df_copy[&#39;trajectory&#39;].astype(str)
                    if &#39;trajectory&#39; in decision_points_df_copy.columns:
                        decision_points_df_copy[&#39;trajectory&#39;] = decision_points_df_copy[&#39;trajectory&#39;].astype(str)
                    
                    try:
                        merged_df = assignments_df_copy.merge(decision_points_df_copy, on=&#39;trajectory&#39;, how=&#39;inner&#39;)
                        branch_points = merged_df[merged_df[&#39;branch&#39;] == i]
                        
                        if len(branch_points) &gt; 0:
                            # Calculate average direction from junction center to actual decision points
                            intercept_x = branch_points[&#39;intercept_x&#39;].values
                            intercept_z = branch_points[&#39;intercept_z&#39;].values
                            
                            # Calculate direction vectors from junction center to decision points
                            dx = intercept_x - junction.cx
                            dz = intercept_z - junction.cz
                            
                            # Calculate average direction (normalize to unit vector)
                            avg_dx = np.mean(dx)
                            avg_dz = np.mean(dz)
                            norm = np.sqrt(avg_dx**2 + avg_dz**2)
                            
                            if norm &gt; 0:
                                branch_direction = np.array([avg_dx/norm, avg_dz/norm])
                            else:
                                # Fallback to cluster center if no valid direction
                                branch_direction = center
                        else:
                            # Fallback to cluster center if no decision points
                            branch_direction = center
                    except Exception:
                        # Fallback to cluster center if merge fails
                        branch_direction = center
                else:
                    # Use cluster center if no decision points available
                    branch_direction = center
                
                # Plot branch marker using calculated direction
                branch_x = junction.cx + r_outer * branch_direction[0]
                branch_z = junction.cz + r_outer * branch_direction[1]
                
                # Plot triangular markers for this branch
                ax.scatter([branch_x], [branch_z], c=color, s=100, marker=marker, 
                          label=f&#39;branch {i} (radial) - {branch_count} trajectories&#39;, 
                          edgecolors=&#39;black&#39;, linewidth=1)
                
                # Draw dashed line from branch to junction center
                ax.plot([branch_x, junction.cx], [branch_z, junction.cz], 
                       color=color, linestyle=&#39;--&#39;, linewidth=2, alpha=0.7)
        
        # Plot all individual intercept points using ACTUAL decision point coordinates
        if decision_points_df is not None and len(decision_points_df) &gt; 0:
            # Ensure trajectory columns have consistent data types for merging
            assignments_df_copy = assignments_df.copy()
            decision_points_df_copy = decision_points_df.copy()
            
            # Convert trajectory columns to string to ensure compatibility
            if &#39;trajectory&#39; in assignments_df_copy.columns:
                assignments_df_copy[&#39;trajectory&#39;] = assignments_df_copy[&#39;trajectory&#39;].astype(str)
            if &#39;trajectory&#39; in decision_points_df_copy.columns:
                decision_points_df_copy[&#39;trajectory&#39;] = decision_points_df_copy[&#39;trajectory&#39;].astype(str)
            
            # Merge decision points with assignments to get branch information
            try:
                merged_df = assignments_df_copy.merge(decision_points_df_copy, on=&#39;trajectory&#39;, how=&#39;inner&#39;)
            except Exception as e:
                # If merge still fails, try alternative approach
                print(f&#34;Warning: Merge failed with error: {e}&#34;)
                print(f&#34;Assignments trajectory type: {assignments_df_copy[&#39;trajectory&#39;].dtype}&#34;)
                print(f&#34;Decision points trajectory type: {decision_points_df_copy[&#39;trajectory&#39;].dtype}&#34;)
                print(f&#34;Sample assignments trajectory values: {assignments_df_copy[&#39;trajectory&#39;].head().tolist()}&#34;)
                print(f&#34;Sample decision points trajectory values: {decision_points_df_copy[&#39;trajectory&#39;].head().tolist()}&#34;)
                # Fall back to theoretical positions
                merged_df = None
            
            if merged_df is not None and len(merged_df) &gt; 0:
                for i, center in enumerate(centers):
                    color = colors[i % len(colors)]
                    branch_assignments = merged_df[merged_df[&#39;branch&#39;] == i]
                    
                    if len(branch_assignments) &gt; 0:
                        # Plot actual decision intercept points
                        intercept_x = branch_assignments[&#39;intercept_x&#39;].values
                        intercept_z = branch_assignments[&#39;intercept_z&#39;].values
                        
                        ax.scatter(intercept_x, intercept_z, 
                                 c=color, s=40, alpha=0.8, marker=&#39;o&#39;, 
                                 edgecolors=&#39;white&#39;, linewidth=1.5,
                                 label=f&#39;branch {i} (actual) - {len(branch_assignments)} trajectories&#39;)
            else:
                # Fall back to theoretical positions if merge failed or no data
                print(&#34;Falling back to theoretical positions due to merge issues&#34;)
                for i, center in enumerate(centers):
                    color = colors[i % len(colors)]
                    branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
                    
                    if len(branch_assignments) &gt; 0:
                        # Calculate base intercept point position using unit vector directions
                        base_x = junction.cx + r_outer * center[0]
                        base_z = junction.cz + r_outer * center[1]
                        
                        # Plot theoretical positions (larger, more visible)
                        ax.scatter([base_x], [base_z], 
                                 c=color, s=80, alpha=0.9, marker=&#39;s&#39;, 
                                 edgecolors=&#39;black&#39;, linewidth=2,
                                 label=f&#39;branch {i} (theoretical) - {len(branch_assignments)} trajectories&#39;)
        else:
            # Fallback: Plot theoretical positions if no decision points data available
            for i, center in enumerate(centers):
                color = colors[i % len(colors)]
                branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
                
                if len(branch_assignments) &gt; 0:
                    # Calculate base intercept point position using unit vector directions
                    base_x = junction.cx + r_outer * center[0]
                    base_z = junction.cz + r_outer * center[1]
                    
                    # Plot theoretical positions (larger, more visible)
                    ax.scatter([base_x], [base_z], 
                             c=color, s=80, alpha=0.9, marker=&#39;s&#39;, 
                             edgecolors=&#39;black&#39;, linewidth=2,
                             label=f&#39;branch {i} (theoretical) - {len(branch_assignments)} trajectories&#39;)
        
        # Add branch statistics text box
        stats_text = &#34;Branch Statistics:\n&#34;
        for i in range(len(centers)):
            count = branch_counts.get(i, 0)
            percentage = (count / total_trajectories * 100) if total_trajectories &gt; 0 else 0
            stats_text += f&#34;Branch {i}: {count} ({percentage:.1f}%)\n&#34;
        
        # Position text box in upper left corner
        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, fontsize=10,
                verticalalignment=&#39;top&#39;, bbox=dict(boxstyle=&#39;round&#39;, facecolor=&#39;white&#39;, alpha=0.8))
    
    ax.set_aspect(&#39;equal&#39;)
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Z&#39;)
    ax.set_title(&#39;Decision intercepts by branch&#39;)
    
    # Move legend outside the plot area to the right
    ax.legend(bbox_to_anchor=(1.05, 1), loc=&#39;upper left&#39;)
    ax.grid(True, alpha=0.3)
    
    # Add mini-map showing overall view
    if all_junctions is not None and len(all_junctions) &gt; 1:
        ax_mini = fig.add_subplot(gs[2])
        
        # Plot all trajectories in mini-map
        for tr in trajectories:
            ax_mini.plot(tr.x, tr.z, color=&#34;0.7&#34;, linewidth=0.3, alpha=0.2)
        
        # Plot all junctions
        for i, junc in enumerate(all_junctions):
            if i == junction_number:
                # Highlight current junction
                circle = plt.Circle((junc.cx, junc.cz), junc.r, fill=False, 
                                  color=&#39;red&#39;, linewidth=3, label=f&#39;Junction {i} (Current)&#39;)
                ax_mini.add_patch(circle)
                ax_mini.scatter([junc.cx], [junc.cz], c=&#39;red&#39;, s=50, marker=&#39;o&#39;, zorder=5)
            else:
                # Other junctions
                circle = plt.Circle((junc.cx, junc.cz), junc.r, fill=False, 
                                  color=&#39;gray&#39;, linewidth=1, alpha=0.7)
                ax_mini.add_patch(circle)
                ax_mini.scatter([junc.cx], [junc.cz], c=&#39;gray&#39;, s=30, marker=&#39;o&#39;, alpha=0.7)
        
        # Add rectangle showing the area shown in main plot
        main_xlim = ax.get_xlim()
        main_ylim = ax.get_ylim()
        rect = plt.Rectangle((main_xlim[0], main_ylim[0]), 
                           main_xlim[1] - main_xlim[0], 
                           main_ylim[1] - main_ylim[0],
                           fill=False, color=&#39;blue&#39;, linewidth=2, linestyle=&#39;--&#39;, alpha=0.8)
        ax_mini.add_patch(rect)
        
        ax_mini.set_aspect(&#39;equal&#39;)
        ax_mini.set_xlabel(&#39;X (Overall View)&#39;)
        ax_mini.set_ylabel(&#39;Z (Overall View)&#39;)
        ax_mini.set_title(&#39;Mini-map: All Junctions and Trajectories&#39;)
        ax_mini.grid(True, alpha=0.3)
        
        # Set reasonable limits for mini-map
        all_x = [tr.x for tr in trajectories]
        all_z = [tr.z for tr in trajectories]
        if all_x and all_z:
            x_min, x_max = min([min(x) for x in all_x]), max([max(x) for x in all_x])
            z_min, z_max = min([min(z) for z in all_z]), max([max(z) for z in all_z])
            margin = 50
            ax_mini.set_xlim(x_min - margin, x_max + margin)
            ax_mini.set_ylim(z_min - margin, z_max + margin)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#39;tight&#39;)
    plt.close()</code></pre>
</details>
<div class="desc"><p>Plot decision intercepts for a junction with branch analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of Trajectory objects</dd>
<dt><strong><code>assignments_df</code></strong></dt>
<dd>DataFrame with trajectory assignments</dd>
<dt><strong><code>mode_log_df</code></strong></dt>
<dd>DataFrame with mode information</dd>
<dt><strong><code>centers</code></strong></dt>
<dd>Array of cluster centers</dd>
<dt><strong><code>junction</code></strong></dt>
<dd>Junction circle</dd>
<dt><strong><code>r_outer</code></strong></dt>
<dd>Outer radius for analysis</dd>
<dt><strong><code>path_length</code></strong></dt>
<dd>Path length threshold</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Epsilon parameter</dd>
<dt><strong><code>linger_delta</code></strong></dt>
<dd>Linger delta parameter</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Output path for the plot</dd>
<dt><strong><code>show_paths</code></strong></dt>
<dd>Whether to show trajectory paths</dd>
<dt><strong><code>legend_noenter_as_line</code></strong></dt>
<dd>Whether to show no-entry as line in legend</dd>
<dt><strong><code>junction_number</code></strong></dt>
<dd>Junction number for title</dd>
<dt><strong><code>all_junctions</code></strong></dt>
<dd>List of all junctions for mini-map</dd>
<dt><strong><code>decision_points_df</code></strong></dt>
<dd>DataFrame with actual decision point coordinates</dd>
</dl></div>
</dd>
<dt id="verta.verta_plotting.plot_flow_graph_map"><code class="name flex">
<span>def <span class="ident">plot_flow_graph_map</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>],<br>chain_df: pandas.core.frame.DataFrame,<br>junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>],<br>*,<br>r_outer_list: List[float] | None = None,<br>out_path: str = 'Flow_Graph_Map.png',<br>junction_names: List[str] | None = None,<br>show_junction_names: bool = True,<br>min_flow_threshold: float = 0.001,<br>arrow_scale: float = 1.0,<br>cached_sequences: Dict[int, List[int]] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_flow_graph_map(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    *,
    r_outer_list: Optional[List[float]] = None,
    out_path: str = &#34;Flow_Graph_Map.png&#34;,
    junction_names: Optional[List[str]] = None,
    show_junction_names: bool = True,
    min_flow_threshold: float = 0.001,
    arrow_scale: float = 1.0,
    cached_sequences: Optional[Dict[int, List[int]]] = None,
) -&gt; None:
    &#34;&#34;&#34;Map-style flow graph showing flow percentages between junctions.
    
    Shows arrows between junctions indicating what percentage of trajectories go directly from each source to each destination.
    
    Args:
        trajectories: List of Trajectory objects
        chain_df: DataFrame with trajectory assignments for each junction
        junctions: List of Circle objects representing junctions
        r_outer_list: List of outer radii for each junction
        out_path: Path to save the plot
        junction_names: Optional list of names for junctions
        show_junction_names: Whether to show junction names
        min_flow_threshold: Minimum flow percentage to show arrow (0.001 = 0.1%)
        arrow_scale: Scale factor for arrow sizes
        cached_sequences: Optional pre-computed node sequences for trajectories
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch
    
    if r_outer_list is None:
        r_outer_list = [None] * len(junctions)
    
    # Generate default junction names if not provided
    if junction_names is None:
        junction_names = [f&#34;J{i}&#34; for i in range(len(junctions))]
    elif len(junction_names) != len(junctions):
        junction_names = junction_names[:len(junctions)]
        while len(junction_names) &lt; len(junctions):
            junction_names.append(f&#34;J{len(junction_names)}&#34;)
    
    # Calculate overall flow matrix (total percentages across all trajectories)
    flow_matrix = _calculate_overall_flow_matrix(trajectories, chain_df, junctions, r_outer_list, cached_sequences)
    
    # Create the plot
    plt.figure(figsize=(12, 10))
    ax = plt.gca()
    
    # Plot all trajectories in light gray background
    for tr in trajectories:
        ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.8, alpha=0.3, zorder=0)
    
    # Draw junction circles
    theta = np.linspace(0, 2*np.pi, 512)
    for i, (junc, r_out) in enumerate(zip(junctions, r_outer_list)):
        # Inner circle
        jr_x = junc.cx + junc.r*np.cos(theta)
        jr_z = junc.cz + junc.r*np.sin(theta)
        ax.plot(jr_x, jr_z, color=&#34;black&#34;, linewidth=1.5, zorder=2)
        
        # Outer circle if provided
        if r_out is not None and float(r_out) &gt; float(junc.r):
            ox = junc.cx + float(r_out)*np.cos(theta)
            oz = junc.cz + float(r_out)*np.sin(theta)
            ax.plot(ox, oz, color=&#34;orange&#34;, linewidth=1.0, alpha=0.7, zorder=2)
        
        # Junction center
        ax.scatter([junc.cx], [junc.cz], color=&#34;black&#34;, s=30, zorder=3)
        
        # Junction name label
        if show_junction_names:
            ax.annotate(junction_names[i], 
                       (junc.cx, junc.cz), 
                       xytext=(8, 8), 
                       textcoords=&#39;offset points&#39;,
                       fontsize=12, 
                       fontweight=&#39;bold&#39;,
                       color=&#39;red&#39;,
                       bbox=dict(boxstyle=&#39;round,pad=0.4&#39;, 
                                facecolor=&#39;white&#39;, 
                                edgecolor=&#39;red&#39;,
                                alpha=0.9),
                       zorder=5)
    
    # Draw flow arrows
    max_flow = np.max(flow_matrix) if flow_matrix.size &gt; 0 else 1.0
    min_arrow_size = 15
    max_arrow_size = 100
    
    # Create node positions for arrow drawing
    node_positions = []
    node_names = []
    
    # Junction positions
    for i, junc in enumerate(junctions):
        node_positions.append((junc.cx, junc.cz))
        node_names.append(f&#34;J{i}&#34;)
    
    for i in range(len(junctions)):
        for j in range(len(junctions)):
            if i != j and flow_matrix[i, j] &gt;= min_flow_threshold:
                # Calculate arrow properties
                flow_percentage = flow_matrix[i, j]
                arrow_size = min_arrow_size + (max_arrow_size - min_arrow_size) * (flow_percentage / max_flow)
                arrow_size *= arrow_scale
                
                # Arrow color based on flow intensity
                color_intensity = flow_percentage / max_flow
                arrow_color = plt.cm.Blues(0.3 + 0.7 * color_intensity)
                
                # Calculate start and end points with appropriate offsets
                start_junc = junctions[i]
                end_junc = junctions[j]
                
                # Calculate arrow direction
                dx = end_junc.cx - start_junc.cx
                dy = end_junc.cz - start_junc.cz
                distance = np.sqrt(dx**2 + dy**2)
                
                if distance &gt; 0:
                    # Normalize direction
                    dx_norm = dx / distance
                    dy_norm = dy / distance
                    
                    # Calculate start and end points
                    start_x = start_junc.cx + dx_norm * start_junc.r
                    start_y = start_junc.cz + dy_norm * start_junc.r
                    end_x = end_junc.cx - dx_norm * end_junc.r
                    end_y = end_junc.cz - dy_norm * end_junc.r
                    
                    # Create arrow
                    arrow = FancyArrowPatch(
                        (start_x, start_y), (end_x, end_y),
                        arrowstyle=&#39;-&gt;&#39;, 
                        mutation_scale=arrow_size,
                        color=arrow_color,
                        linewidth=max(1, int(2 + 3 * flow_percentage / max_flow)),
                        alpha=0.8,
                        zorder=4
                    )
                    ax.add_patch(arrow)
                    
                    # Add flow percentage label
                    mid_x = (start_x + end_x) / 2
                    mid_y = (start_y + end_y) / 2
                    
                    # Offset label slightly to avoid overlap
                    label_offset_x = -dy_norm * 10
                    label_offset_y = dx_norm * 10
                    
                    ax.annotate(f&#39;{flow_percentage:.1%}&#39;, 
                               (mid_x + label_offset_x, mid_y + label_offset_y),
                               ha=&#39;center&#39;, va=&#39;center&#39;,
                               fontsize=9,
                               fontweight=&#39;bold&#39;,
                               color=&#39;darkblue&#39;,
                               bbox=dict(boxstyle=&#39;round,pad=0.3&#39;, 
                                        facecolor=&#39;white&#39;, 
                                        edgecolor=&#39;darkblue&#39;,
                                        alpha=0.9),
                               zorder=6)
    
    # Set equal aspect and labels
    ax.set_aspect(&#34;equal&#34;)
    ax.set_xlabel(&#34;X&#34;)
    ax.set_ylabel(&#34;Z&#34;)
    ax.set_title(&#34;Flow Graph Map&#34;, fontsize=14, fontweight=&#39;bold&#39;)
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], color=&#39;black&#39;, linewidth=2, label=&#39;Junction&#39;),
        plt.Line2D([0], [0], color=&#39;orange&#39;, linewidth=2, label=&#39;Analysis Radius&#39;),
        plt.Line2D([0], [0], color=&#39;blue&#39;, linewidth=2, label=&#39;Flow Direction (%)&#39;),
        plt.Line2D([0], [0], color=&#39;0.8&#39;, linewidth=1, alpha=0.3, label=&#39;Trajectories&#39;)
    ]
    
    ax.legend(handles=legend_elements, loc=&#39;upper right&#39;)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.close()</code></pre>
</details>
<div class="desc"><p>Map-style flow graph showing flow percentages between junctions.</p>
<p>Shows arrows between junctions indicating what percentage of trajectories go directly from each source to each destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of Trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with trajectory assignments for each junction</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of Circle objects representing junctions</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>List of outer radii for each junction</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Path to save the plot</dd>
<dt><strong><code>junction_names</code></strong></dt>
<dd>Optional list of names for junctions</dd>
<dt><strong><code>show_junction_names</code></strong></dt>
<dd>Whether to show junction names</dd>
<dt><strong><code>min_flow_threshold</code></strong></dt>
<dd>Minimum flow percentage to show arrow (0.001 = 0.1%)</dd>
<dt><strong><code>arrow_scale</code></strong></dt>
<dd>Scale factor for arrow sizes</dd>
<dt><strong><code>cached_sequences</code></strong></dt>
<dd>Optional pre-computed node sequences for trajectories</dd>
</dl></div>
</dd>
<dt id="verta.verta_plotting.plot_per_junction_flow_graph"><code class="name flex">
<span>def <span class="ident">plot_per_junction_flow_graph</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>],<br>chain_df: pandas.core.frame.DataFrame,<br>junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>],<br>*,<br>r_outer_list: List[float] | None = None,<br>out_path: str = 'Per_Junction_Flow_Graph.png',<br>junction_names: List[str] | None = None,<br>show_junction_names: bool = True,<br>min_flow_threshold: float = 0.001,<br>arrow_scale: float = 1.0,<br>cached_sequences: Dict[int, List[int]] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_per_junction_flow_graph(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    *,
    r_outer_list: Optional[List[float]] = None,
    out_path: str = &#34;Per_Junction_Flow_Graph.png&#34;,
    junction_names: Optional[List[str]] = None,
    show_junction_names: bool = True,
    min_flow_threshold: float = 0.001,  # Reduced from 0.01 to show flows as low as 0.1%
    arrow_scale: float = 1.0,
    cached_sequences: Optional[Dict[int, List[int]]] = None,
) -&gt; None:
    &#34;&#34;&#34;Map-style flow graph showing percentages per junction including zones.
    
    Shows arrows between junctions and zones indicating what percentage of trajectories leaving each junction go directly to each destination.
    
    Args:
        trajectories: List of Trajectory objects
        chain_df: DataFrame with trajectory assignments for each junction
        junctions: List of Circle objects representing junctions
        r_outer_list: List of outer radii for each junction
        out_path: Path to save the plot
        junction_names: Optional list of names for junctions
        show_junction_names: Whether to show junction names
        min_flow_threshold: Minimum flow percentage to show arrow (0.001 = 0.1%)
        arrow_scale: Scale factor for arrow sizes
        start_zones: Optional list of start zone definitions
        end_zones: Optional list of end zone definitions
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch
    
    if r_outer_list is None:
        r_outer_list = [None] * len(junctions)
    
    # Generate default junction names if not provided
    if junction_names is None:
        junction_names = [f&#34;J{i}&#34; for i in range(len(junctions))]
    elif len(junction_names) != len(junctions):
        junction_names = junction_names[:len(junctions)]
        while len(junction_names) &lt; len(junctions):
            junction_names.append(f&#34;J{len(junction_names)}&#34;)
    
    # Calculate per-junction flows
    flow_matrix = _calculate_per_junction_flows(trajectories, chain_df, junctions, r_outer_list, cached_sequences)
    
    # Create the plot
    plt.figure(figsize=(12, 10))
    ax = plt.gca()
    
    # Plot all trajectories in light gray background
    for tr in trajectories:
        ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.8, alpha=0.3, zorder=0)
    
    # Draw junction circles
    theta = np.linspace(0, 2*np.pi, 512)
    for i, (junc, r_out) in enumerate(zip(junctions, r_outer_list)):
        # Inner circle
        jr_x = junc.cx + junc.r*np.cos(theta)
        jr_z = junc.cz + junc.r*np.sin(theta)
        ax.plot(jr_x, jr_z, color=&#34;black&#34;, linewidth=1.5, zorder=2)
        
        # Outer circle if provided
        if r_out is not None and float(r_out) &gt; float(junc.r):
            ox = junc.cx + float(r_out)*np.cos(theta)
            oz = junc.cz + float(r_out)*np.sin(theta)
            ax.plot(ox, oz, color=&#34;orange&#34;, linewidth=1.0, alpha=0.7, zorder=2)
        
        # Junction center
        ax.scatter([junc.cx], [junc.cz], color=&#34;black&#34;, s=30, zorder=3)
        
        # Junction name label
        if show_junction_names:
            ax.annotate(junction_names[i], 
                       (junc.cx, junc.cz), 
                       xytext=(8, 8), 
                       textcoords=&#39;offset points&#39;,
                       fontsize=12, 
                       fontweight=&#39;bold&#39;,
                       color=&#39;red&#39;,
                       bbox=dict(boxstyle=&#39;round,pad=0.4&#39;, 
                                facecolor=&#39;white&#39;, 
                                edgecolor=&#39;red&#39;,
                                alpha=0.9),
                       zorder=5)
    
    # Draw flow arrows with improved labeling
    max_flow = np.max(flow_matrix) if flow_matrix.size &gt; 0 else 1.0
    min_arrow_size = 15
    max_arrow_size = 100
    
    print(f&#34;DEBUG: Per-junction flow matrix:\n{flow_matrix}&#34;)
    print(f&#34;DEBUG: Max flow: {max_flow}&#34;)
    
    # Create node positions for arrow drawing
    node_positions = []
    node_names = []
    
    # Junction positions
    for i, junc in enumerate(junctions):
        node_positions.append((junc.cx, junc.cz))
        node_names.append(f&#34;J{i}&#34;)
    
    for i in range(len(junctions)):
        for j in range(len(junctions)):
            if i != j and flow_matrix[i, j] &gt;= min_flow_threshold:
                # Calculate arrow properties
                flow_percentage = flow_matrix[i, j]
                arrow_size = min_arrow_size + (max_arrow_size - min_arrow_size) * (flow_percentage / max_flow)
                arrow_size *= arrow_scale
                
                # Arrow color based on flow intensity
                color_intensity = flow_percentage / max_flow
                arrow_color = plt.cm.Greens(0.3 + 0.7 * color_intensity)  # Use green for per-junction flows
                
                # Calculate start and end points with appropriate offsets
                start_junc = junctions[i]
                end_junc = junctions[j]
                
                # Calculate arrow direction
                dx = end_junc.cx - start_junc.cx
                dy = end_junc.cz - start_junc.cz
                distance = np.sqrt(dx**2 + dy**2)
                
                if distance &gt; 0:
                    # Normalize direction
                    dx_norm = dx / distance
                    dy_norm = dy / distance
                    
                    # Calculate start and end points
                    start_x = start_junc.cx + dx_norm * start_junc.r
                    start_y = start_junc.cz + dy_norm * start_junc.r
                    end_x = end_junc.cx - dx_norm * end_junc.r
                    end_y = end_junc.cz - dy_norm * end_junc.r
                    
                    # Create arrow
                    arrow = FancyArrowPatch(
                        (start_x, start_y), (end_x, end_y),
                        arrowstyle=&#39;-&gt;&#39;, 
                        mutation_scale=arrow_size,
                        color=arrow_color,
                        linewidth=max(1, int(2 + 3 * flow_percentage / max_flow)),
                        alpha=0.8,
                        zorder=4
                    )
                    ax.add_patch(arrow)
                    
                    # Add flow percentage label with better positioning
                    mid_x = (start_x + end_x) / 2
                    mid_y = (start_y + end_y) / 2
                    
                    # Offset label slightly to avoid overlap
                    label_offset_x = -dy_norm * 10  # Perpendicular offset
                    label_offset_y = dx_norm * 10
                    
                    ax.annotate(f&#39;{flow_percentage:.1%}&#39;, 
                               (mid_x + label_offset_x, mid_y + label_offset_y),
                               ha=&#39;center&#39;, va=&#39;center&#39;,
                               fontsize=9,
                               fontweight=&#39;bold&#39;,
                               color=&#39;darkgreen&#39;,
                               bbox=dict(boxstyle=&#39;round,pad=0.3&#39;, 
                                        facecolor=&#39;white&#39;, 
                                        edgecolor=&#39;darkgreen&#39;,
                                        alpha=0.9),
                               zorder=6)
    
    # Set equal aspect and labels
    ax.set_aspect(&#34;equal&#34;)
    ax.set_xlabel(&#34;X&#34;)
    ax.set_ylabel(&#34;Z&#34;)
    ax.set_title(&#34;Flow Graph: Per-Junction Percentages&#34;, fontsize=14, fontweight=&#39;bold&#39;)
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], color=&#39;black&#39;, linewidth=2, label=&#39;Junction&#39;),
        plt.Line2D([0], [0], color=&#39;orange&#39;, linewidth=2, label=&#39;Decision Radius&#39;),
        plt.Line2D([0], [0], color=&#39;green&#39;, linewidth=2, label=&#39;Flow Direction (per-junction %)&#39;),
        plt.Line2D([0], [0], color=&#39;0.8&#39;, linewidth=1, alpha=0.3, label=&#39;Trajectories&#39;)
    ]
    
    ax.legend(handles=legend_elements, loc=&#39;upper right&#39;)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.close()</code></pre>
</details>
<div class="desc"><p>Map-style flow graph showing percentages per junction including zones.</p>
<p>Shows arrows between junctions and zones indicating what percentage of trajectories leaving each junction go directly to each destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of Trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with trajectory assignments for each junction</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of Circle objects representing junctions</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>List of outer radii for each junction</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Path to save the plot</dd>
<dt><strong><code>junction_names</code></strong></dt>
<dd>Optional list of names for junctions</dd>
<dt><strong><code>show_junction_names</code></strong></dt>
<dd>Whether to show junction names</dd>
<dt><strong><code>min_flow_threshold</code></strong></dt>
<dd>Minimum flow percentage to show arrow (0.001 = 0.1%)</dd>
<dt><strong><code>arrow_scale</code></strong></dt>
<dd>Scale factor for arrow sizes</dd>
<dt><strong><code>start_zones</code></strong></dt>
<dd>Optional list of start zone definitions</dd>
<dt><strong><code>end_zones</code></strong></dt>
<dd>Optional list of end zone definitions</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="verta.verta_plotting.PlotConfig"><code class="flex name class">
<span>class <span class="ident">PlotConfig</span></span>
<span>(</span><span>dpi: int = 100,<br>figsize: Tuple[float, float] = (12, 8),<br>tight_layout: bool = True,<br>branch_colors: Tuple[str, ...] = ('#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'),<br>fontsize: int = 12,<br>title_fontsize: int = 14,<br>label_fontsize: int = 12,<br>legend_fontsize: int = 10,<br>arrow_scale: float = 0.8,<br>arrow_width: float = 0.002,<br>arrow_head_width: float = 0.01,<br>arrow_head_length: float = 0.01,<br>junction_alpha: float = 0.3,<br>junction_edge_width: float = 2.0,<br>trajectory_alpha: float = 0.6,<br>trajectory_linewidth: float = 1.0,<br>grid_alpha: float = 0.3,<br>grid_linewidth: float = 0.5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class PlotConfig:
    &#34;&#34;&#34;Centralized plot configuration settings.&#34;&#34;&#34;
    
    # Figure settings
    dpi: int = 100
    figsize: Tuple[float, float] = (12, 8)
    tight_layout: bool = True
    
    # Color settings - colors are used again if more than 10 branches
    branch_colors: Tuple[str, ...] = (&#39;#1f77b4&#39;, &#39;#ff7f0e&#39;, &#39;#2ca02c&#39;, &#39;#d62728&#39;, &#39;#9467bd&#39;, &#39;#8c564b&#39;, &#39;#e377c2&#39;, &#39;#7f7f7f&#39;, &#39;#bcbd22&#39;, &#39;#17becf&#39;)
    
    # Font settings
    fontsize: int = 12
    title_fontsize: int = 14
    label_fontsize: int = 12
    legend_fontsize: int = 10
    
    # Arrow settings
    arrow_scale: float = 0.8
    arrow_width: float = 0.002
    arrow_head_width: float = 0.01
    arrow_head_length: float = 0.01
    
    # Junction settings
    junction_alpha: float = 0.3
    junction_edge_width: float = 2.0
    
    # Trajectory settings
    trajectory_alpha: float = 0.6
    trajectory_linewidth: float = 1.0
    
    # Grid settings
    grid_alpha: float = 0.3
    grid_linewidth: float = 0.5
    
    def apply_to_figure(self, fig) -&gt; None:
        &#34;&#34;&#34;Apply configuration to a matplotlib figure.&#34;&#34;&#34;
        if self.tight_layout:
            fig.tight_layout()
    
    def get_branch_color(self, branch_idx: int) -&gt; str:
        &#34;&#34;&#34;Get color for a branch index.&#34;&#34;&#34;
        return self.branch_colors[branch_idx % len(self.branch_colors)]</code></pre>
</details>
<div class="desc"><p>Centralized plot configuration settings.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="verta.verta_plotting.PlotConfig.arrow_head_length"><code class="name">var <span class="ident">arrow_head_length</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.arrow_head_width"><code class="name">var <span class="ident">arrow_head_width</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.arrow_scale"><code class="name">var <span class="ident">arrow_scale</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.arrow_width"><code class="name">var <span class="ident">arrow_width</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.branch_colors"><code class="name">var <span class="ident">branch_colors</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.dpi"><code class="name">var <span class="ident">dpi</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.figsize"><code class="name">var <span class="ident">figsize</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.fontsize"><code class="name">var <span class="ident">fontsize</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.grid_alpha"><code class="name">var <span class="ident">grid_alpha</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.grid_linewidth"><code class="name">var <span class="ident">grid_linewidth</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.junction_alpha"><code class="name">var <span class="ident">junction_alpha</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.junction_edge_width"><code class="name">var <span class="ident">junction_edge_width</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.label_fontsize"><code class="name">var <span class="ident">label_fontsize</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.legend_fontsize"><code class="name">var <span class="ident">legend_fontsize</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.tight_layout"><code class="name">var <span class="ident">tight_layout</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.title_fontsize"><code class="name">var <span class="ident">title_fontsize</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.trajectory_alpha"><code class="name">var <span class="ident">trajectory_alpha</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.trajectory_linewidth"><code class="name">var <span class="ident">trajectory_linewidth</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="verta.verta_plotting.PlotConfig.apply_to_figure"><code class="name flex">
<span>def <span class="ident">apply_to_figure</span></span>(<span>self, fig) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_to_figure(self, fig) -&gt; None:
    &#34;&#34;&#34;Apply configuration to a matplotlib figure.&#34;&#34;&#34;
    if self.tight_layout:
        fig.tight_layout()</code></pre>
</details>
<div class="desc"><p>Apply configuration to a matplotlib figure.</p></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.get_branch_color"><code class="name flex">
<span>def <span class="ident">get_branch_color</span></span>(<span>self, branch_idx: int) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_branch_color(self, branch_idx: int) -&gt; str:
    &#34;&#34;&#34;Get color for a branch index.&#34;&#34;&#34;
    return self.branch_colors[branch_idx % len(self.branch_colors)]</code></pre>
</details>
<div class="desc"><p>Get color for a branch index.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="verta" href="index.html">verta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="verta.verta_plotting.plot_chain_overview" href="#verta.verta_plotting.plot_chain_overview">plot_chain_overview</a></code></li>
<li><code><a title="verta.verta_plotting.plot_chain_small_multiples" href="#verta.verta_plotting.plot_chain_small_multiples">plot_chain_small_multiples</a></code></li>
<li><code><a title="verta.verta_plotting.plot_decision_intercepts" href="#verta.verta_plotting.plot_decision_intercepts">plot_decision_intercepts</a></code></li>
<li><code><a title="verta.verta_plotting.plot_flow_graph_map" href="#verta.verta_plotting.plot_flow_graph_map">plot_flow_graph_map</a></code></li>
<li><code><a title="verta.verta_plotting.plot_per_junction_flow_graph" href="#verta.verta_plotting.plot_per_junction_flow_graph">plot_per_junction_flow_graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="verta.verta_plotting.PlotConfig" href="#verta.verta_plotting.PlotConfig">PlotConfig</a></code></h4>
<ul class="">
<li><code><a title="verta.verta_plotting.PlotConfig.apply_to_figure" href="#verta.verta_plotting.PlotConfig.apply_to_figure">apply_to_figure</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_head_length" href="#verta.verta_plotting.PlotConfig.arrow_head_length">arrow_head_length</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_head_width" href="#verta.verta_plotting.PlotConfig.arrow_head_width">arrow_head_width</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_scale" href="#verta.verta_plotting.PlotConfig.arrow_scale">arrow_scale</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_width" href="#verta.verta_plotting.PlotConfig.arrow_width">arrow_width</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.branch_colors" href="#verta.verta_plotting.PlotConfig.branch_colors">branch_colors</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.dpi" href="#verta.verta_plotting.PlotConfig.dpi">dpi</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.figsize" href="#verta.verta_plotting.PlotConfig.figsize">figsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.fontsize" href="#verta.verta_plotting.PlotConfig.fontsize">fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.get_branch_color" href="#verta.verta_plotting.PlotConfig.get_branch_color">get_branch_color</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.grid_alpha" href="#verta.verta_plotting.PlotConfig.grid_alpha">grid_alpha</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.grid_linewidth" href="#verta.verta_plotting.PlotConfig.grid_linewidth">grid_linewidth</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.junction_alpha" href="#verta.verta_plotting.PlotConfig.junction_alpha">junction_alpha</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.junction_edge_width" href="#verta.verta_plotting.PlotConfig.junction_edge_width">junction_edge_width</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.label_fontsize" href="#verta.verta_plotting.PlotConfig.label_fontsize">label_fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.legend_fontsize" href="#verta.verta_plotting.PlotConfig.legend_fontsize">legend_fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.tight_layout" href="#verta.verta_plotting.PlotConfig.tight_layout">tight_layout</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.title_fontsize" href="#verta.verta_plotting.PlotConfig.title_fontsize">title_fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.trajectory_alpha" href="#verta.verta_plotting.PlotConfig.trajectory_alpha">trajectory_alpha</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.trajectory_linewidth" href="#verta.verta_plotting.PlotConfig.trajectory_linewidth">trajectory_linewidth</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
