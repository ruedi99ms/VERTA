<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>verta.verta_plotting API documentation</title>
<meta name="description" content="VERTA Plotting Module …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>verta.verta_plotting</code></h1>
</header>
<section id="section-intro">
<p>VERTA Plotting Module</p>
<p>This module provides plotting functions for trajectory analysis and visualization.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
VERTA Plotting Module

This module provides plotting functions for trajectory analysis and visualization.
&#34;&#34;&#34;

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from typing import List, Optional, Dict, Any
import os
from dataclasses import dataclass
from typing import Tuple

try:
    from .verta_data_loader import Trajectory
    from .verta_geometry import Circle
except ImportError:
    from verta.verta_data_loader import Trajectory
    from verta.verta_geometry import Circle


@dataclass
class PlotConfig:
    &#34;&#34;&#34;Centralized plot configuration settings.&#34;&#34;&#34;
    
    # Figure settings
    dpi: int = 100
    figsize: Tuple[float, float] = (12, 8)
    tight_layout: bool = True
    
    # Color settings - colors are used again if more than 10 branches
    branch_colors: Tuple[str, ...] = (&#39;#1f77b4&#39;, &#39;#ff7f0e&#39;, &#39;#2ca02c&#39;, &#39;#d62728&#39;, &#39;#9467bd&#39;, &#39;#8c564b&#39;, &#39;#e377c2&#39;, &#39;#7f7f7f&#39;, &#39;#bcbd22&#39;, &#39;#17becf&#39;)
    
    # Font settings
    fontsize: int = 12
    title_fontsize: int = 14
    label_fontsize: int = 12
    legend_fontsize: int = 10
    
    # Arrow settings
    arrow_scale: float = 0.8
    arrow_width: float = 0.002
    arrow_head_width: float = 0.01
    arrow_head_length: float = 0.01
    
    # Junction settings
    junction_alpha: float = 0.3
    junction_edge_width: float = 2.0
    
    # Trajectory settings
    trajectory_alpha: float = 0.6
    trajectory_linewidth: float = 1.0
    
    # Grid settings
    grid_alpha: float = 0.3
    grid_linewidth: float = 0.5
    
    def apply_to_figure(self, fig) -&gt; None:
        &#34;&#34;&#34;Apply configuration to a matplotlib figure.&#34;&#34;&#34;
        if self.tight_layout:
            fig.tight_layout()
    
    def get_branch_color(self, branch_idx: int) -&gt; str:
        &#34;&#34;&#34;Get color for a branch index.&#34;&#34;&#34;
        return self.branch_colors[branch_idx % len(self.branch_colors)]


# Default plot configuration instance
DEFAULT_PLOT_CONFIG = PlotConfig()


def _draw_tilted_rectangle(ax, zone, color, label, zorder=2):
    &#34;&#34;&#34;Helper function to draw a tilted rectangle zone.&#34;&#34;&#34;
    if &#39;x_min&#39; in zone:
        x_min, x_max = zone[&#39;x_min&#39;], zone[&#39;x_max&#39;]
        z_min, z_max = zone[&#39;z_min&#39;], zone[&#39;z_max&#39;]
    else:
        x_min, x_max = zone[&#39;x1&#39;], zone[&#39;x2&#39;]
        z_min, z_max = zone[&#39;z1&#39;], zone[&#39;z2&#39;]
    
    tilt = zone.get(&#39;tilt&#39;, 0)
    
    # Create rectangle corners
    corners_x = [x_min, x_max, x_max, x_min, x_min]
    corners_z = [z_min, z_min, z_max, z_max, z_min]
    
    # Apply rotation if tilted
    if tilt != 0:
        center_x = (x_min + x_max) / 2
        center_z = (z_min + z_max) / 2
        
        cos_tilt = np.cos(np.radians(tilt))
        sin_tilt = np.sin(np.radians(tilt))
        
        # Rotate each corner
        rotated_x = []
        rotated_z = []
        for x, z in zip(corners_x, corners_z):
            # Translate to origin
            x_rel = x - center_x
            z_rel = z - center_z
            
            # Apply rotation
            x_rot = x_rel * cos_tilt - z_rel * sin_tilt
            z_rot = x_rel * sin_tilt + z_rel * cos_tilt
            
            # Translate back
            rotated_x.append(x_rot + center_x)
            rotated_z.append(z_rot + center_z)
        
        corners_x = rotated_x
        corners_z = rotated_z
    
    # Draw rectangle
    ax.plot(corners_x, corners_z, color=color, linewidth=2, alpha=0.7, zorder=zorder)
    
    # Draw center
    center_x = (x_min + x_max) / 2
    center_z = (z_min + z_max) / 2
    ax.scatter([center_x], [center_z], color=color, s=50, marker=&#39;s&#39;, zorder=zorder+1)
    
    return center_x, center_z


def plot_decision_intercepts(
    trajectories: List[Trajectory],
    assignments_df: pd.DataFrame,
    mode_log_df: pd.DataFrame,
    centers: np.ndarray,
    junction: Circle,
    r_outer: float,
    path_length: float,
    epsilon: float,
    linger_delta: float,
    *,
    out_path: str = &#34;Decision_Intercepts.png&#34;,
    show_paths: bool = True,
    legend_noenter_as_line: bool = False,
    junction_number: int = 0,
    all_junctions: List[Circle] = None,
    decision_points_df: pd.DataFrame = None
) -&gt; None:
    &#34;&#34;&#34;Plot decision intercepts for a junction with branch analysis.
    
    Args:
        trajectories: List of Trajectory objects
        assignments_df: DataFrame with trajectory assignments
        mode_log_df: DataFrame with mode information
        centers: Array of cluster centers
        junction: Junction circle
        r_outer: Outer radius for analysis
        path_length: Path length threshold
        epsilon: Epsilon parameter
        linger_delta: Linger delta parameter
        out_path: Output path for the plot
        show_paths: Whether to show trajectory paths
        legend_noenter_as_line: Whether to show no-entry as line in legend
        junction_number: Junction number for title
        all_junctions: List of all junctions for mini-map
        decision_points_df: DataFrame with actual decision point coordinates
    &#34;&#34;&#34;
    # Create a more comprehensive layout with heading and mini-map
    fig = plt.figure(figsize=(16, 12))
    
    # Create a grid layout: heading at top, main plot in center, mini-map at bottom
    gs = fig.add_gridspec(3, 1, height_ratios=[0.5, 3, 1], hspace=0.3)
    
    # Add heading
    ax_title = fig.add_subplot(gs[0])
    ax_title.text(0.5, 0.5, f&#39;Junction {junction_number} - Decision Intercepts Analysis&#39;, 
                  ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=16, fontweight=&#39;bold&#39;)
    ax_title.set_xlim(0, 1)
    ax_title.set_ylim(0, 1)
    ax_title.axis(&#39;off&#39;)
    
    # Main plot
    ax = fig.add_subplot(gs[1])
    
    # Plot trajectories if requested
    if show_paths:
        for tr in trajectories:
            ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.5, alpha=0.3)
    
    # Plot junction
    theta = np.linspace(0, 2*np.pi, 100)
    junction_x = junction.cx + junction.r * np.cos(theta)
    junction_z = junction.cz + junction.r * np.sin(theta)
    ax.plot(junction_x, junction_z, &#39;k-&#39;, linewidth=2, label=&#39;Junction&#39;)
    
    # Plot outer radius
    outer_x = junction.cx + r_outer * np.cos(theta)
    outer_z = junction.cz + r_outer * np.sin(theta)
    ax.plot(outer_x, outer_z, &#39;orange&#39;, linewidth=1, alpha=0.7, label=&#39;Analysis Radius&#39;)
    
    # Plot junction center
    ax.scatter([junction.cx], [junction.cz], c=&#39;black&#39;, s=50, marker=&#39;o&#39;, 
              label=&#39;Junction Center&#39;)
    
    # Plot branch analysis with triangular markers and connections
    if len(centers) &gt; 0 and assignments_df is not None:
        # Define colors and markers for different branches
        colors = [&#39;blue&#39;, &#39;orange&#39;, &#39;green&#39;, &#39;red&#39;, &#39;purple&#39;, &#39;brown&#39;, &#39;pink&#39;, &#39;gray&#39;]
        markers = [&#39;^&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;v&#39;, &#39;s&#39;, &#39;D&#39;, &#39;o&#39;, &#39;h&#39;]
        
        # Calculate branch statistics
        branch_counts = assignments_df[&#39;branch&#39;].value_counts().sort_index()
        total_trajectories = len(assignments_df)
        
        # Plot branch markers and directions
        for i, center in enumerate(centers):
            color = colors[i % len(colors)]
            marker = markers[i % len(markers)]
            
            # Get assignments for this branch
            branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
            branch_count = len(branch_assignments)
            
            if branch_count &gt; 0:
                # Calculate branch direction from actual decision points if available
                if decision_points_df is not None and len(decision_points_df) &gt; 0:
                    # Merge decision points with assignments to get actual coordinates
                    assignments_df_copy = assignments_df.copy()
                    decision_points_df_copy = decision_points_df.copy()
                    
                    # Convert trajectory columns to string to ensure compatibility
                    if &#39;trajectory&#39; in assignments_df_copy.columns:
                        assignments_df_copy[&#39;trajectory&#39;] = assignments_df_copy[&#39;trajectory&#39;].astype(str)
                    if &#39;trajectory&#39; in decision_points_df_copy.columns:
                        decision_points_df_copy[&#39;trajectory&#39;] = decision_points_df_copy[&#39;trajectory&#39;].astype(str)
                    
                    try:
                        merged_df = assignments_df_copy.merge(decision_points_df_copy, on=&#39;trajectory&#39;, how=&#39;inner&#39;)
                        branch_points = merged_df[merged_df[&#39;branch&#39;] == i]
                        
                        if len(branch_points) &gt; 0:
                            # Calculate average direction from junction center to actual decision points
                            intercept_x = branch_points[&#39;intercept_x&#39;].values
                            intercept_z = branch_points[&#39;intercept_z&#39;].values
                            
                            # Calculate direction vectors from junction center to decision points
                            dx = intercept_x - junction.cx
                            dz = intercept_z - junction.cz
                            
                            # Calculate average direction (normalize to unit vector)
                            avg_dx = np.mean(dx)
                            avg_dz = np.mean(dz)
                            norm = np.sqrt(avg_dx**2 + avg_dz**2)
                            
                            if norm &gt; 0:
                                branch_direction = np.array([avg_dx/norm, avg_dz/norm])
                            else:
                                # Fallback to cluster center if no valid direction
                                branch_direction = center
                        else:
                            # Fallback to cluster center if no decision points
                            branch_direction = center
                    except Exception:
                        # Fallback to cluster center if merge fails
                        branch_direction = center
                else:
                    # Use cluster center if no decision points available
                    branch_direction = center
                
                # Plot branch marker using calculated direction
                branch_x = junction.cx + r_outer * branch_direction[0]
                branch_z = junction.cz + r_outer * branch_direction[1]
                
                # Plot triangular markers for this branch
                ax.scatter([branch_x], [branch_z], c=color, s=100, marker=marker, 
                          label=f&#39;branch {i} (radial) - {branch_count} trajectories&#39;, 
                          edgecolors=&#39;black&#39;, linewidth=1)
                
                # Draw dashed line from branch to junction center
                ax.plot([branch_x, junction.cx], [branch_z, junction.cz], 
                       color=color, linestyle=&#39;--&#39;, linewidth=2, alpha=0.7)
        
        # Plot all individual intercept points using ACTUAL decision point coordinates
        if decision_points_df is not None and len(decision_points_df) &gt; 0:
            # Ensure trajectory columns have consistent data types for merging
            assignments_df_copy = assignments_df.copy()
            decision_points_df_copy = decision_points_df.copy()
            
            # Convert trajectory columns to string to ensure compatibility
            if &#39;trajectory&#39; in assignments_df_copy.columns:
                assignments_df_copy[&#39;trajectory&#39;] = assignments_df_copy[&#39;trajectory&#39;].astype(str)
            if &#39;trajectory&#39; in decision_points_df_copy.columns:
                decision_points_df_copy[&#39;trajectory&#39;] = decision_points_df_copy[&#39;trajectory&#39;].astype(str)
            
            # Merge decision points with assignments to get branch information
            try:
                merged_df = assignments_df_copy.merge(decision_points_df_copy, on=&#39;trajectory&#39;, how=&#39;inner&#39;)
            except Exception as e:
                # If merge still fails, try alternative approach
                print(f&#34;Warning: Merge failed with error: {e}&#34;)
                print(f&#34;Assignments trajectory type: {assignments_df_copy[&#39;trajectory&#39;].dtype}&#34;)
                print(f&#34;Decision points trajectory type: {decision_points_df_copy[&#39;trajectory&#39;].dtype}&#34;)
                print(f&#34;Sample assignments trajectory values: {assignments_df_copy[&#39;trajectory&#39;].head().tolist()}&#34;)
                print(f&#34;Sample decision points trajectory values: {decision_points_df_copy[&#39;trajectory&#39;].head().tolist()}&#34;)
                # Fall back to theoretical positions
                merged_df = None
            
            if merged_df is not None and len(merged_df) &gt; 0:
                for i, center in enumerate(centers):
                    color = colors[i % len(colors)]
                    branch_assignments = merged_df[merged_df[&#39;branch&#39;] == i]
                    
                    if len(branch_assignments) &gt; 0:
                        # Plot actual decision intercept points
                        intercept_x = branch_assignments[&#39;intercept_x&#39;].values
                        intercept_z = branch_assignments[&#39;intercept_z&#39;].values
                        
                        ax.scatter(intercept_x, intercept_z, 
                                 c=color, s=40, alpha=0.8, marker=&#39;o&#39;, 
                                 edgecolors=&#39;white&#39;, linewidth=1.5,
                                 label=f&#39;branch {i} (actual) - {len(branch_assignments)} trajectories&#39;)
            else:
                # Fall back to theoretical positions if merge failed or no data
                print(&#34;Falling back to theoretical positions due to merge issues&#34;)
                for i, center in enumerate(centers):
                    color = colors[i % len(colors)]
                    branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
                    
                    if len(branch_assignments) &gt; 0:
                        # Calculate base intercept point position using unit vector directions
                        base_x = junction.cx + r_outer * center[0]
                        base_z = junction.cz + r_outer * center[1]
                        
                        # Plot theoretical positions (larger, more visible)
                        ax.scatter([base_x], [base_z], 
                                 c=color, s=80, alpha=0.9, marker=&#39;s&#39;, 
                                 edgecolors=&#39;black&#39;, linewidth=2,
                                 label=f&#39;branch {i} (theoretical) - {len(branch_assignments)} trajectories&#39;)
        else:
            # Fallback: Plot theoretical positions if no decision points data available
            for i, center in enumerate(centers):
                color = colors[i % len(colors)]
                branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
                
                if len(branch_assignments) &gt; 0:
                    # Calculate base intercept point position using unit vector directions
                    base_x = junction.cx + r_outer * center[0]
                    base_z = junction.cz + r_outer * center[1]
                    
                    # Plot theoretical positions (larger, more visible)
                    ax.scatter([base_x], [base_z], 
                             c=color, s=80, alpha=0.9, marker=&#39;s&#39;, 
                             edgecolors=&#39;black&#39;, linewidth=2,
                             label=f&#39;branch {i} (theoretical) - {len(branch_assignments)} trajectories&#39;)
        
        # Add branch statistics text box
        stats_text = &#34;Branch Statistics:\n&#34;
        for i in range(len(centers)):
            count = branch_counts.get(i, 0)
            percentage = (count / total_trajectories * 100) if total_trajectories &gt; 0 else 0
            stats_text += f&#34;Branch {i}: {count} ({percentage:.1f}%)\n&#34;
        
        # Position text box in upper left corner
        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, fontsize=10,
                verticalalignment=&#39;top&#39;, bbox=dict(boxstyle=&#39;round&#39;, facecolor=&#39;white&#39;, alpha=0.8))
    
    ax.set_aspect(&#39;equal&#39;)
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Z&#39;)
    ax.set_title(&#39;Decision intercepts by branch&#39;)
    
    # Move legend outside the plot area to the right
    ax.legend(bbox_to_anchor=(1.05, 1), loc=&#39;upper left&#39;)
    ax.grid(True, alpha=0.3)
    
    # Add mini-map showing overall view
    if all_junctions is not None and len(all_junctions) &gt; 1:
        ax_mini = fig.add_subplot(gs[2])
        
        # Plot all trajectories in mini-map
        for tr in trajectories:
            ax_mini.plot(tr.x, tr.z, color=&#34;0.7&#34;, linewidth=0.3, alpha=0.2)
        
        # Plot all junctions
        for i, junc in enumerate(all_junctions):
            if i == junction_number:
                # Highlight current junction
                circle = plt.Circle((junc.cx, junc.cz), junc.r, fill=False, 
                                  color=&#39;red&#39;, linewidth=3, label=f&#39;Junction {i} (Current)&#39;)
                ax_mini.add_patch(circle)
                ax_mini.scatter([junc.cx], [junc.cz], c=&#39;red&#39;, s=50, marker=&#39;o&#39;, zorder=5)
            else:
                # Other junctions
                circle = plt.Circle((junc.cx, junc.cz), junc.r, fill=False, 
                                  color=&#39;gray&#39;, linewidth=1, alpha=0.7)
                ax_mini.add_patch(circle)
                ax_mini.scatter([junc.cx], [junc.cz], c=&#39;gray&#39;, s=30, marker=&#39;o&#39;, alpha=0.7)
        
        # Add rectangle showing the area shown in main plot
        main_xlim = ax.get_xlim()
        main_ylim = ax.get_ylim()
        rect = plt.Rectangle((main_xlim[0], main_ylim[0]), 
                           main_xlim[1] - main_xlim[0], 
                           main_ylim[1] - main_ylim[0],
                           fill=False, color=&#39;blue&#39;, linewidth=2, linestyle=&#39;--&#39;, alpha=0.8)
        ax_mini.add_patch(rect)
        
        ax_mini.set_aspect(&#39;equal&#39;)
        ax_mini.set_xlabel(&#39;X (Overall View)&#39;)
        ax_mini.set_ylabel(&#39;Z (Overall View)&#39;)
        ax_mini.set_title(&#39;Mini-map: All Junctions and Trajectories&#39;)
        ax_mini.grid(True, alpha=0.3)
        
        # Set reasonable limits for mini-map
        all_x = [tr.x for tr in trajectories]
        all_z = [tr.z for tr in trajectories]
        if all_x and all_z:
            x_min, x_max = min([min(x) for x in all_x]), max([max(x) for x in all_x])
            z_min, z_max = min([min(z) for z in all_z]), max([max(z) for z in all_z])
            margin = 50
            ax_mini.set_xlim(x_min - margin, x_max + margin)
            ax_mini.set_ylim(z_min - margin, z_max + margin)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#39;tight&#39;)
    plt.close()


def plot_flow_graph_map(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    *,
    r_outer_list: Optional[List[float]] = None,
    out_path: str = &#34;Flow_Graph_Map.png&#34;,
    junction_names: Optional[List[str]] = None,
    show_junction_names: bool = True,
    min_flow_threshold: float = 0.001,
    arrow_scale: float = 1.0,
    cached_sequences: Optional[Dict[int, List[int]]] = None,
) -&gt; None:
    &#34;&#34;&#34;Map-style flow graph showing flow percentages between junctions.
    
    Shows arrows between junctions indicating what percentage of trajectories go directly from each source to each destination.
    
    Args:
        trajectories: List of Trajectory objects
        chain_df: DataFrame with trajectory assignments for each junction
        junctions: List of Circle objects representing junctions
        r_outer_list: List of outer radii for each junction
        out_path: Path to save the plot
        junction_names: Optional list of names for junctions
        show_junction_names: Whether to show junction names
        min_flow_threshold: Minimum flow percentage to show arrow (0.001 = 0.1%)
        arrow_scale: Scale factor for arrow sizes
        cached_sequences: Optional pre-computed node sequences for trajectories
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch
    
    if r_outer_list is None:
        r_outer_list = [None] * len(junctions)
    
    # Generate default junction names if not provided
    if junction_names is None:
        junction_names = [f&#34;J{i}&#34; for i in range(len(junctions))]
    elif len(junction_names) != len(junctions):
        junction_names = junction_names[:len(junctions)]
        while len(junction_names) &lt; len(junctions):
            junction_names.append(f&#34;J{len(junction_names)}&#34;)
    
    # Calculate overall flow matrix (total percentages across all trajectories)
    flow_matrix = _calculate_overall_flow_matrix(trajectories, chain_df, junctions, r_outer_list, cached_sequences)
    
    # Create the plot
    plt.figure(figsize=(12, 10))
    ax = plt.gca()
    
    # Plot all trajectories in light gray background
    for tr in trajectories:
        ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.8, alpha=0.3, zorder=0)
    
    # Draw junction circles
    theta = np.linspace(0, 2*np.pi, 512)
    for i, (junc, r_out) in enumerate(zip(junctions, r_outer_list)):
        # Inner circle
        jr_x = junc.cx + junc.r*np.cos(theta)
        jr_z = junc.cz + junc.r*np.sin(theta)
        ax.plot(jr_x, jr_z, color=&#34;black&#34;, linewidth=1.5, zorder=2)
        
        # Outer circle if provided
        if r_out is not None and float(r_out) &gt; float(junc.r):
            ox = junc.cx + float(r_out)*np.cos(theta)
            oz = junc.cz + float(r_out)*np.sin(theta)
            ax.plot(ox, oz, color=&#34;orange&#34;, linewidth=1.0, alpha=0.7, zorder=2)
        
        # Junction center
        ax.scatter([junc.cx], [junc.cz], color=&#34;black&#34;, s=30, zorder=3)
        
        # Junction name label
        if show_junction_names:
            ax.annotate(junction_names[i], 
                       (junc.cx, junc.cz), 
                       xytext=(8, 8), 
                       textcoords=&#39;offset points&#39;,
                       fontsize=12, 
                       fontweight=&#39;bold&#39;,
                       color=&#39;red&#39;,
                       bbox=dict(boxstyle=&#39;round,pad=0.4&#39;, 
                                facecolor=&#39;white&#39;, 
                                edgecolor=&#39;red&#39;,
                                alpha=0.9),
                       zorder=5)
    
    # Draw flow arrows
    max_flow = np.max(flow_matrix) if flow_matrix.size &gt; 0 else 1.0
    min_arrow_size = 15
    max_arrow_size = 100
    
    # Create node positions for arrow drawing
    node_positions = []
    node_names = []
    
    # Junction positions
    for i, junc in enumerate(junctions):
        node_positions.append((junc.cx, junc.cz))
        node_names.append(f&#34;J{i}&#34;)
    
    for i in range(len(junctions)):
        for j in range(len(junctions)):
            if i != j and flow_matrix[i, j] &gt;= min_flow_threshold:
                # Calculate arrow properties
                flow_percentage = flow_matrix[i, j]
                arrow_size = min_arrow_size + (max_arrow_size - min_arrow_size) * (flow_percentage / max_flow)
                arrow_size *= arrow_scale
                
                # Arrow color based on flow intensity
                color_intensity = flow_percentage / max_flow
                arrow_color = plt.cm.Blues(0.3 + 0.7 * color_intensity)
                
                # Calculate start and end points with appropriate offsets
                start_junc = junctions[i]
                end_junc = junctions[j]
                
                # Calculate arrow direction
                dx = end_junc.cx - start_junc.cx
                dy = end_junc.cz - start_junc.cz
                distance = np.sqrt(dx**2 + dy**2)
                
                if distance &gt; 0:
                    # Normalize direction
                    dx_norm = dx / distance
                    dy_norm = dy / distance
                    
                    # Calculate start and end points
                    start_x = start_junc.cx + dx_norm * start_junc.r
                    start_y = start_junc.cz + dy_norm * start_junc.r
                    end_x = end_junc.cx - dx_norm * end_junc.r
                    end_y = end_junc.cz - dy_norm * end_junc.r
                    
                    # Create arrow
                    arrow = FancyArrowPatch(
                        (start_x, start_y), (end_x, end_y),
                        arrowstyle=&#39;-&gt;&#39;, 
                        mutation_scale=arrow_size,
                        color=arrow_color,
                        linewidth=max(1, int(2 + 3 * flow_percentage / max_flow)),
                        alpha=0.8,
                        zorder=4
                    )
                    ax.add_patch(arrow)
                    
                    # Add flow percentage label
                    mid_x = (start_x + end_x) / 2
                    mid_y = (start_y + end_y) / 2
                    
                    # Offset label slightly to avoid overlap
                    label_offset_x = -dy_norm * 10
                    label_offset_y = dx_norm * 10
                    
                    ax.annotate(f&#39;{flow_percentage:.1%}&#39;, 
                               (mid_x + label_offset_x, mid_y + label_offset_y),
                               ha=&#39;center&#39;, va=&#39;center&#39;,
                               fontsize=9,
                               fontweight=&#39;bold&#39;,
                               color=&#39;darkblue&#39;,
                               bbox=dict(boxstyle=&#39;round,pad=0.3&#39;, 
                                        facecolor=&#39;white&#39;, 
                                        edgecolor=&#39;darkblue&#39;,
                                        alpha=0.9),
                               zorder=6)
    
    # Set equal aspect and labels
    ax.set_aspect(&#34;equal&#34;)
    ax.set_xlabel(&#34;X&#34;)
    ax.set_ylabel(&#34;Z&#34;)
    ax.set_title(&#34;Flow Graph Map&#34;, fontsize=14, fontweight=&#39;bold&#39;)
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], color=&#39;black&#39;, linewidth=2, label=&#39;Junction&#39;),
        plt.Line2D([0], [0], color=&#39;orange&#39;, linewidth=2, label=&#39;Analysis Radius&#39;),
        plt.Line2D([0], [0], color=&#39;blue&#39;, linewidth=2, label=&#39;Flow Direction (%)&#39;),
        plt.Line2D([0], [0], color=&#39;0.8&#39;, linewidth=1, alpha=0.3, label=&#39;Trajectories&#39;)
    ]
    
    ax.legend(handles=legend_elements, loc=&#39;upper right&#39;)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.close()


def plot_per_junction_flow_graph(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    *,
    r_outer_list: Optional[List[float]] = None,
    out_path: str = &#34;Per_Junction_Flow_Graph.png&#34;,
    junction_names: Optional[List[str]] = None,
    show_junction_names: bool = True,
    min_flow_threshold: float = 0.001,  # Reduced from 0.01 to show flows as low as 0.1%
    arrow_scale: float = 1.0,
    cached_sequences: Optional[Dict[int, List[int]]] = None,
) -&gt; None:
    &#34;&#34;&#34;Map-style flow graph showing percentages per junction including zones.
    
    Shows arrows between junctions and zones indicating what percentage of trajectories leaving each junction go directly to each destination.
    
    Args:
        trajectories: List of Trajectory objects
        chain_df: DataFrame with trajectory assignments for each junction
        junctions: List of Circle objects representing junctions
        r_outer_list: List of outer radii for each junction
        out_path: Path to save the plot
        junction_names: Optional list of names for junctions
        show_junction_names: Whether to show junction names
        min_flow_threshold: Minimum flow percentage to show arrow (0.001 = 0.1%)
        arrow_scale: Scale factor for arrow sizes
        start_zones: Optional list of start zone definitions
        end_zones: Optional list of end zone definitions
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch
    
    if r_outer_list is None:
        r_outer_list = [None] * len(junctions)
    
    # Generate default junction names if not provided
    if junction_names is None:
        junction_names = [f&#34;J{i}&#34; for i in range(len(junctions))]
    elif len(junction_names) != len(junctions):
        junction_names = junction_names[:len(junctions)]
        while len(junction_names) &lt; len(junctions):
            junction_names.append(f&#34;J{len(junction_names)}&#34;)
    
    # Calculate per-junction flows
    flow_matrix = _calculate_per_junction_flows(trajectories, chain_df, junctions, r_outer_list, cached_sequences)
    
    # Create the plot
    plt.figure(figsize=(12, 10))
    ax = plt.gca()
    
    # Plot all trajectories in light gray background
    for tr in trajectories:
        ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.8, alpha=0.3, zorder=0)
    
    # Draw junction circles
    theta = np.linspace(0, 2*np.pi, 512)
    for i, (junc, r_out) in enumerate(zip(junctions, r_outer_list)):
        # Inner circle
        jr_x = junc.cx + junc.r*np.cos(theta)
        jr_z = junc.cz + junc.r*np.sin(theta)
        ax.plot(jr_x, jr_z, color=&#34;black&#34;, linewidth=1.5, zorder=2)
        
        # Outer circle if provided
        if r_out is not None and float(r_out) &gt; float(junc.r):
            ox = junc.cx + float(r_out)*np.cos(theta)
            oz = junc.cz + float(r_out)*np.sin(theta)
            ax.plot(ox, oz, color=&#34;orange&#34;, linewidth=1.0, alpha=0.7, zorder=2)
        
        # Junction center
        ax.scatter([junc.cx], [junc.cz], color=&#34;black&#34;, s=30, zorder=3)
        
        # Junction name label
        if show_junction_names:
            ax.annotate(junction_names[i], 
                       (junc.cx, junc.cz), 
                       xytext=(8, 8), 
                       textcoords=&#39;offset points&#39;,
                       fontsize=12, 
                       fontweight=&#39;bold&#39;,
                       color=&#39;red&#39;,
                       bbox=dict(boxstyle=&#39;round,pad=0.4&#39;, 
                                facecolor=&#39;white&#39;, 
                                edgecolor=&#39;red&#39;,
                                alpha=0.9),
                       zorder=5)
    
    # Draw flow arrows with improved labeling
    max_flow = np.max(flow_matrix) if flow_matrix.size &gt; 0 else 1.0
    min_arrow_size = 15
    max_arrow_size = 100
    
    print(f&#34;DEBUG: Per-junction flow matrix:\n{flow_matrix}&#34;)
    print(f&#34;DEBUG: Max flow: {max_flow}&#34;)
    
    # Create node positions for arrow drawing
    node_positions = []
    node_names = []
    
    # Junction positions
    for i, junc in enumerate(junctions):
        node_positions.append((junc.cx, junc.cz))
        node_names.append(f&#34;J{i}&#34;)
    
    for i in range(len(junctions)):
        for j in range(len(junctions)):
            if i != j and flow_matrix[i, j] &gt;= min_flow_threshold:
                # Calculate arrow properties
                flow_percentage = flow_matrix[i, j]
                arrow_size = min_arrow_size + (max_arrow_size - min_arrow_size) * (flow_percentage / max_flow)
                arrow_size *= arrow_scale
                
                # Arrow color based on flow intensity
                color_intensity = flow_percentage / max_flow
                arrow_color = plt.cm.Greens(0.3 + 0.7 * color_intensity)  # Use green for per-junction flows
                
                # Calculate start and end points with appropriate offsets
                start_junc = junctions[i]
                end_junc = junctions[j]
                
                # Calculate arrow direction
                dx = end_junc.cx - start_junc.cx
                dy = end_junc.cz - start_junc.cz
                distance = np.sqrt(dx**2 + dy**2)
                
                if distance &gt; 0:
                    # Normalize direction
                    dx_norm = dx / distance
                    dy_norm = dy / distance
                    
                    # Calculate start and end points
                    start_x = start_junc.cx + dx_norm * start_junc.r
                    start_y = start_junc.cz + dy_norm * start_junc.r
                    end_x = end_junc.cx - dx_norm * end_junc.r
                    end_y = end_junc.cz - dy_norm * end_junc.r
                    
                    # Create arrow
                    arrow = FancyArrowPatch(
                        (start_x, start_y), (end_x, end_y),
                        arrowstyle=&#39;-&gt;&#39;, 
                        mutation_scale=arrow_size,
                        color=arrow_color,
                        linewidth=max(1, int(2 + 3 * flow_percentage / max_flow)),
                        alpha=0.8,
                        zorder=4
                    )
                    ax.add_patch(arrow)
                    
                    # Add flow percentage label with better positioning
                    mid_x = (start_x + end_x) / 2
                    mid_y = (start_y + end_y) / 2
                    
                    # Offset label slightly to avoid overlap
                    label_offset_x = -dy_norm * 10  # Perpendicular offset
                    label_offset_y = dx_norm * 10
                    
                    ax.annotate(f&#39;{flow_percentage:.1%}&#39;, 
                               (mid_x + label_offset_x, mid_y + label_offset_y),
                               ha=&#39;center&#39;, va=&#39;center&#39;,
                               fontsize=9,
                               fontweight=&#39;bold&#39;,
                               color=&#39;darkgreen&#39;,
                               bbox=dict(boxstyle=&#39;round,pad=0.3&#39;, 
                                        facecolor=&#39;white&#39;, 
                                        edgecolor=&#39;darkgreen&#39;,
                                        alpha=0.9),
                               zorder=6)
    
    # Set equal aspect and labels
    ax.set_aspect(&#34;equal&#34;)
    ax.set_xlabel(&#34;X&#34;)
    ax.set_ylabel(&#34;Z&#34;)
    ax.set_title(&#34;Flow Graph: Per-Junction Percentages&#34;, fontsize=14, fontweight=&#39;bold&#39;)
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], color=&#39;black&#39;, linewidth=2, label=&#39;Junction&#39;),
        plt.Line2D([0], [0], color=&#39;orange&#39;, linewidth=2, label=&#39;Decision Radius&#39;),
        plt.Line2D([0], [0], color=&#39;green&#39;, linewidth=2, label=&#39;Flow Direction (per-junction %)&#39;),
        plt.Line2D([0], [0], color=&#39;0.8&#39;, linewidth=1, alpha=0.3, label=&#39;Trajectories&#39;)
    ]
    
    ax.legend(handles=legend_elements, loc=&#39;upper right&#39;)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.close()


def _calculate_flow_matrix(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    r_outer_list: Optional[List[float]] = None
) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculate flow matrix showing flow percentages between junctions.&#34;&#34;&#34;
    n_junctions = len(junctions)
    flow_counts = np.zeros((n_junctions, n_junctions))
    
    # Ensure chain_df is properly indexed
    if &#39;trajectory&#39; in chain_df.columns:
        chain_df = chain_df.set_index(&#39;trajectory&#39;)
    
    branch_cols = [f&#34;branch_j{i}&#34; for i in range(n_junctions)]
    
    for tr in trajectories:
        tid = tr.tid
        if tid not in chain_df.index:
            continue
            
        # Get junction assignments for this trajectory
        assignments = []
        for i in range(n_junctions):
            b = chain_df.loc[tid].get(branch_cols[i], None)
            if b is not None and not (isinstance(b, float) and np.isnan(b)) and int(b) &gt;= 0:
                assignments.append(i)
        
        # Only consider trajectories that pass through at least 2 junctions
        if len(assignments) &gt;= 2:
            # Find all pairs of junctions this trajectory connects
            for i in range(len(assignments)):
                for j in range(len(assignments)):
                    if i != j:
                        from_junc = assignments[i]
                        to_junc = assignments[j]
                        
                        # Check if this is a direct spatial connection
                        if _is_direct_spatial_connection(tr, junctions, from_junc, to_junc):
                            flow_counts[from_junc, to_junc] += 1
    
    # Convert counts to percentages
    total_flows = np.sum(flow_counts)
    if total_flows &gt; 0:
        flow_matrix = flow_counts / total_flows
    else:
        flow_matrix = flow_counts
    
    return flow_matrix


def _track_trajectory_junction_sequence(
    trajectory: Trajectory, 
    junctions: List[Circle], 
    r_outer_list: List[float]
) -&gt; List[int]:
    &#34;&#34;&#34;
    Track the temporal sequence of junction visits for a trajectory.
    
    Returns list of junction indices in the order they were visited.
    &#34;&#34;&#34;
    sequence = []
    current_junction = None
    
    # Debug: Log trajectory info (only once per trajectory)
    traj_id = getattr(trajectory, &#39;tid&#39;, &#39;unknown&#39;)
    print(f&#34;🔍 DEBUG: Tracking trajectory {traj_id}, length: {len(trajectory.x)} points&#34;)
    print(f&#34;🔍 DEBUG: Trajectory range: X={min(trajectory.x):.1f}-{max(trajectory.x):.1f}, Z={min(trajectory.z):.1f}-{max(trajectory.z):.1f}&#34;)
    
    junction_detections = 0
    points_processed = 0
    
    for point_idx in range(len(trajectory.x)):
        x, z = trajectory.x[point_idx], trajectory.z[point_idx]
        points_processed += 1
        
        # Check if we&#39;re at a new junction
        for junction_idx, (junction, r_outer) in enumerate(zip(junctions, r_outer_list)):
            distance = np.sqrt((x - junction.cx)**2 + (z - junction.cz)**2)
            
            if distance &lt;= r_outer:
                junction_detections += 1
                if current_junction != junction_idx:
                    sequence.append(junction_idx)
                    current_junction = junction_idx
                    print(f&#34;🔍 DEBUG: Added junction {junction_idx} to sequence at point {point_idx}&#34;)
                break
        else:
            # Not at any junction
            current_junction = None
    
    print(f&#34;DEBUG: Trajectory {traj_id} final sequence: {sequence}&#34;)
    print(f&#34;DEBUG: Total junction detections: {junction_detections}, Points processed: {points_processed}&#34;)
    
    return sequence


def _calculate_per_junction_flows(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    r_outer_list: Optional[List[float]] = None,
    cached_sequences: Optional[Dict[int, List[int]]] = None
) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculate per-junction flow matrix showing percentages of trajectories leaving each junction.&#34;&#34;&#34;
    n_junctions = len(junctions)
    flow_counts = np.zeros((n_junctions, n_junctions))
    junction_exits = np.zeros(n_junctions)  # Count trajectories leaving each junction
    
    # Use cached sequences if provided, otherwise do spatial tracking
    if cached_sequences is not None:
        print(f&#34;🔍 DEBUG: Using cached sequences for {len(cached_sequences)} trajectories&#34;)
        for tr_idx, tr in enumerate(trajectories):
            junction_sequence = cached_sequences.get(tr_idx, [])
            
            # Extract transitions from sequence (only count real transitions between different junctions)
            if len(junction_sequence) &gt;= 2:
                for i in range(len(junction_sequence) - 1):
                    from_junc = junction_sequence[i]
                    to_junc = junction_sequence[i + 1]
                    # Only count transitions between different junctions
                    if from_junc != to_junc:
                        flow_counts[from_junc, to_junc] += 1
                        junction_exits[from_junc] += 1
    else:
        print(f&#34;DEBUG: No cached sequences provided, doing spatial tracking for {len(trajectories)} trajectories&#34;)
        # Use spatial tracking to determine junction visit sequences
        for tr_idx, tr in enumerate(trajectories):
            # Track junction sequence for this trajectory using spatial tracking
            junction_sequence = _track_trajectory_junction_sequence(tr, junctions, r_outer_list)
            
            # Extract transitions from sequence (only count real transitions between different junctions)
            if len(junction_sequence) &gt;= 2:
                for i in range(len(junction_sequence) - 1):
                    from_junc = junction_sequence[i]
                    to_junc = junction_sequence[i + 1]
                    # Only count transitions between different junctions
                    if from_junc != to_junc:
                        flow_counts[from_junc, to_junc] += 1
                        junction_exits[from_junc] += 1
    
    # Convert counts to percentages per junction
    flow_matrix = np.zeros((n_junctions, n_junctions))
    for i in range(n_junctions):
        if junction_exits[i] &gt; 0:
            flow_matrix[i, :] = flow_counts[i, :] / junction_exits[i]
    
    return flow_matrix


def _calculate_overall_flow_matrix(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    r_outer_list: Optional[List[float]] = None,
    cached_sequences: Optional[Dict[int, List[int]]] = None
) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculate overall flow matrix showing percentage of all trajectories making each transition.&#34;&#34;&#34;
    n_junctions = len(junctions)
    flow_counts = np.zeros((n_junctions, n_junctions))
    total_trajectories = len(trajectories)
    
    # Use cached sequences if provided, otherwise do spatial tracking
    if cached_sequences is not None:
        print(f&#34;🔍 DEBUG: Using cached sequences for overall flow calculation&#34;)
        for tr_idx, tr in enumerate(trajectories):
            junction_sequence = cached_sequences.get(tr_idx, [])
            
            # Extract transitions from sequence (only count real transitions between different junctions)
            if len(junction_sequence) &gt;= 2:
                for i in range(len(junction_sequence) - 1):
                    from_junc = junction_sequence[i]
                    to_junc = junction_sequence[i + 1]
                    # Only count transitions between different junctions
                    if from_junc != to_junc:
                        flow_counts[from_junc, to_junc] += 1
    else:
        print(f&#34;🔍 DEBUG: No cached sequences provided, doing spatial tracking for overall flow calculation&#34;)
        # Use spatial tracking to determine junction visit sequences
        for tr_idx, tr in enumerate(trajectories):
            # Track junction sequence for this trajectory using spatial tracking
            junction_sequence = _track_trajectory_junction_sequence(tr, junctions, r_outer_list)
            
            # Extract transitions from sequence (only count real transitions between different junctions)
            if len(junction_sequence) &gt;= 2:
                for i in range(len(junction_sequence) - 1):
                    from_junc = junction_sequence[i]
                    to_junc = junction_sequence[i + 1]
                    # Only count transitions between different junctions
                    if from_junc != to_junc:
                        flow_counts[from_junc, to_junc] += 1
    
    # Convert counts to percentages of all trajectories (not per-junction percentages)
    flow_matrix = np.zeros((n_junctions, n_junctions))
    if total_trajectories &gt; 0:
        flow_matrix = flow_counts / total_trajectories
    
    print(f&#34;🔍 DEBUG: Overall flow matrix - total trajectories: {total_trajectories}&#34;)
    print(f&#34;🔍 DEBUG: Overall flow matrix:\n{flow_matrix}&#34;)
    
    return flow_matrix


def _is_direct_spatial_connection(
    trajectory: Trajectory,
    junctions: List[Circle],
    from_junc_idx: int,
    to_junc_idx: int
) -&gt; bool:
    &#34;&#34;&#34;Check if trajectory goes directly from one junction to another spatially.&#34;&#34;&#34;
    from_junc = junctions[from_junc_idx]
    to_junc = junctions[to_junc_idx]
    
    # Find points where trajectory is near each junction
    from_distances = np.sqrt((trajectory.x - from_junc.cx)**2 + (trajectory.z - from_junc.cz)**2)
    to_distances = np.sqrt((trajectory.x - to_junc.cx)**2 + (trajectory.z - to_junc.cz)**2)
    
    # Find indices where trajectory is near each junction (within 2x radius)
    from_near_indices = np.where(from_distances &lt;= from_junc.r * 2)[0]
    to_near_indices = np.where(to_distances &lt;= to_junc.r * 2)[0]
    
    if len(from_near_indices) == 0 or len(to_near_indices) == 0:
        return False
    
    # Check if trajectory goes from first junction to second junction
    # (first junction appears before second junction in the trajectory)
    from_max_idx = np.max(from_near_indices)
    to_min_idx = np.min(to_near_indices)
    
    # Direct connection if trajectory goes from first junction to second
    if from_max_idx &lt; to_min_idx:
        # Check if trajectory doesn&#39;t pass through other junctions in between
        for i, junc in enumerate(junctions):
            if i == from_junc_idx or i == to_junc_idx:
                continue
                
            # Check if trajectory intersects this junction between the two points
            segment_distances = np.sqrt((trajectory.x[from_max_idx:to_min_idx] - junc.cx)**2 + 
                                       (trajectory.z[from_max_idx:to_min_idx] - junc.cz)**2)
            if np.any(segment_distances &lt;= junc.r):
                return False  # Trajectory passes through another junction
        
        return True  # Direct connection
    
    return False


def _calculate_flow_matrix_with_zones(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    r_outer_list: Optional[List[float]] = None,
    start_zones: Optional[List[Dict]] = None,
    end_zones: Optional[List[Dict]] = None,
    cached_sequences: Optional[Dict[int, List[int]]] = None
) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculate overall flow matrix including start/end zones (total percentages).&#34;&#34;&#34;
    n_junctions = len(junctions)
    n_start_zones = len(start_zones) if start_zones else 0
    n_end_zones = len(end_zones) if end_zones else 0
    total_nodes = n_junctions + n_start_zones + n_end_zones
    
    flow_counts = np.zeros((total_nodes, total_nodes))
    total_trajectories = len(trajectories)
    trajectories_with_sequences = 0
    
    # Compute node sequences for flow calculations
    cached_sequences = {}
    for tr_idx, tr in enumerate(trajectories):
        cached_sequences[tr_idx] = _track_trajectory_node_sequence(tr, junctions, r_outer_list, start_zones, end_zones)
    
    for tr_idx, tr in enumerate(trajectories):
        # Use cached sequence
        node_sequence = cached_sequences.get(tr_idx, [])
        
        if len(node_sequence) &gt; 0:
            trajectories_with_sequences += 1
            
            # Count flows between consecutive nodes (ensure unique transitions only)
            unique_transitions = set()
            for i in range(len(node_sequence) - 1):
                from_node = node_sequence[i]
                to_node = node_sequence[i + 1]
                transition = (from_node, to_node)
                
                # Only count each unique transition once per trajectory
                if transition not in unique_transitions:
                    unique_transitions.add(transition)
                    flow_counts[from_node, to_node] += 1
    
    print(f&#34;DEBUG: {trajectories_with_sequences}/{total_trajectories} trajectories have node sequences&#34;)
    if start_zones:
        start_zone_idx = len(junctions)
        start_flows = np.sum(flow_counts[start_zone_idx, :])
        print(f&#34;DEBUG: Total flows from start zone: {start_flows}&#34;)
    if end_zones:
        end_zone_idx = len(junctions) + len(start_zones)
        end_flows = np.sum(flow_counts[:, end_zone_idx])
        print(f&#34;DEBUG: Total flows to end zone: {end_flows}&#34;)
    
    # Convert counts to percentages
    total_flows = np.sum(flow_counts)
    if total_flows &gt; 0:
        flow_matrix = flow_counts / total_flows
    else:
        flow_matrix = flow_counts
    
    return flow_matrix


def _calculate_per_junction_flows_with_zones(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    r_outer_list: Optional[List[float]] = None,
    start_zones: Optional[List[Dict]] = None,
    end_zones: Optional[List[Dict]] = None,
    gui_mode: bool = False,
    cached_sequences: Optional[Dict[int, List[int]]] = None
) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculate per-junction flow matrix including zones.
    
    Args:
        cached_sequences: Optional pre-computed node sequences for trajectories
                         (key: trajectory index, value: node sequence)
    &#34;&#34;&#34;
    n_junctions = len(junctions)
    n_start_zones = len(start_zones) if start_zones else 0
    n_end_zones = len(end_zones) if end_zones else 0
    total_nodes = n_junctions + n_start_zones + n_end_zones
    
    flow_counts = np.zeros((total_nodes, total_nodes))
    node_exits = np.zeros(total_nodes)  # Count trajectories leaving each node
    node_entries = np.zeros(total_nodes)  # Count trajectories entering each node
    total_trajectories = len(trajectories)
    trajectories_with_sequences = 0
    
    # Compute node sequences for flow calculations
    cached_sequences = {}
    for tr_idx, tr in enumerate(trajectories):
        cached_sequences[tr_idx] = _track_trajectory_node_sequence(tr, junctions, r_outer_list, start_zones, end_zones)
    
    # Only print debug stats in terminal mode (not GUI)
    if not gui_mode:
        print(f&#34;\n=== TRAJECTORY FLOW DEBUG STATISTICS ===&#34;)
        print(f&#34;Total trajectories: {total_trajectories}&#34;)
        print(f&#34;Junctions: {n_junctions}, Start zones: {n_start_zones}, End zones: {n_end_zones}&#34;)
        print(f&#34;Total nodes: {total_nodes}&#34;)
    
    for tr_idx, tr in enumerate(trajectories):
        # Use cached sequence
        node_sequence = cached_sequences.get(tr_idx, [])
        
        if len(node_sequence) &gt; 0:
            trajectories_with_sequences += 1
            
            # Count flows between consecutive nodes (ensure unique transitions only)
            unique_transitions = set()
            for i in range(len(node_sequence) - 1):
                from_node = node_sequence[i]
                to_node = node_sequence[i + 1]
                transition = (from_node, to_node)
                
                # Only count each unique transition once per trajectory
                if transition not in unique_transitions:
                    unique_transitions.add(transition)
                    flow_counts[from_node, to_node] += 1
                    node_exits[from_node] += 1  # Count exits from source node
                    node_entries[to_node] += 1   # Count entries to destination node
    
    # Only print debug stats in terminal mode (not GUI)
    if not gui_mode:
        print(f&#34;\nTrajectories with sequences: {trajectories_with_sequences}/{total_trajectories} ({trajectories_with_sequences/total_trajectories*100:.1f}%)&#34;)
        
        # Print statistics for each node
        print(f&#34;\n=== NODE STATISTICS ===&#34;)
        for i in range(total_nodes):
            if i &lt; n_junctions:
                node_name = f&#34;J{i}&#34;
                node_type = &#34;Junction&#34;
            elif i &lt; n_junctions + n_start_zones:
                zone_idx = i - n_junctions
                node_name = f&#34;S{zone_idx + 1}&#34;
                node_type = &#34;Start Zone&#34;
            else:
                zone_idx = i - n_junctions - n_start_zones
                node_name = f&#34;E{zone_idx + 1}&#34;
                node_type = &#34;End Zone&#34;
            
            entries = int(node_entries[i])
            exits = int(node_exits[i])
            print(f&#34;{node_name} ({node_type}): {entries} entries, {exits} exits&#34;)
            
            # Show outgoing flows
            outgoing_flows = []
            for j in range(total_nodes):
                if flow_counts[i, j] &gt; 0:
                    if j &lt; n_junctions:
                        dest_name = f&#34;J{j}&#34;
                    elif j &lt; n_junctions + n_start_zones:
                        dest_name = f&#34;S{j - n_junctions + 1}&#34;
                    else:
                        dest_name = f&#34;E{j - n_junctions - n_start_zones + 1}&#34;
                    outgoing_flows.append(f&#34;{dest_name}({int(flow_counts[i, j])})&#34;)
            
            if outgoing_flows:
                print(f&#34;  → Outgoing flows: {&#39;, &#39;.join(outgoing_flows)}&#34;)
    
    # Convert counts to percentages per node
    flow_matrix = np.zeros((total_nodes, total_nodes))
    for i in range(total_nodes):
        if node_exits[i] &gt; 0:
            flow_matrix[i, :] = flow_counts[i, :] / node_exits[i]
    
    # Only print flow percentages in terminal mode (not GUI)
    if not gui_mode:
        print(f&#34;\n=== FLOW PERCENTAGES ===&#34;)
        for i in range(total_nodes):
            if node_exits[i] &gt; 0:
                if i &lt; n_junctions:
                    node_name = f&#34;J{i}&#34;
                elif i &lt; n_junctions + n_start_zones:
                    node_name = f&#34;S{i - n_junctions + 1}&#34;
                else:
                    node_name = f&#34;E{i - n_junctions - n_start_zones + 1}&#34;
                
                print(f&#34;\n{node_name} outgoing percentages:&#34;)
                for j in range(total_nodes):
                    if flow_matrix[i, j] &gt; 0.01:  # Only show flows &gt; 1%
                        if j &lt; n_junctions:
                            dest_name = f&#34;J{j}&#34;
                        elif j &lt; n_junctions + n_start_zones:
                            dest_name = f&#34;S{j - n_junctions + 1}&#34;
                        else:
                            dest_name = f&#34;E{j - n_junctions - n_start_zones + 1}&#34;
                        print(f&#34;  → {dest_name}: {flow_matrix[i, j]*100:.1f}%&#34;)
        
        print(f&#34;\n=== END DEBUG STATISTICS ===\n&#34;)
    
    return flow_matrix


def _track_trajectory_node_sequence(
    trajectory: Trajectory,
    junctions: List[Circle],
    r_outer_list: Optional[List[float]] = None,
    start_zones: Optional[List[Dict]] = None,
    end_zones: Optional[List[Dict]] = None
) -&gt; List[int]:
    &#34;&#34;&#34;
    Track the temporal sequence of node visits for a trajectory.
    
    Returns list of node indices in the order they were visited.
    Node indices: 0 to n_junctions-1 for junctions, n_junctions to n_junctions+n_start_zones-1 for start zones, n_junctions+n_start_zones to n_junctions+n_start_zones+n_end_zones-1 for end zones.
    
    This function prioritizes nodes by temporal order (which is reached first along the trajectory path), not by distance or type priority.
    &#34;&#34;&#34;
    sequence = []
    current_node = None
    
    if r_outer_list is None:
        r_outer_list = [None] * len(junctions)
    
    # Track the trajectory point by point to find temporal order
    for point_idx in range(len(trajectory.x)):
        x, z = trajectory.x[point_idx], trajectory.z[point_idx]
        
        # Check all possible nodes and find which one this point is in
        nodes_at_this_point = []
        
        # Check junctions
        for junction_idx, (junction, r_outer) in enumerate(zip(junctions, r_outer_list)):
            distance = np.sqrt((x - junction.cx)**2 + (z - junction.cz)**2)
            radius_to_check = r_outer if r_outer is not None else junction.r
            
            if distance &lt;= radius_to_check:
                nodes_at_this_point.append(junction_idx)
        
        # Check start zones
        if start_zones:
            for zone_idx, zone in enumerate(start_zones):
                if _identify_zone(x, z, zone):
                    node_idx = len(junctions) + zone_idx
                    nodes_at_this_point.append(node_idx)
        
        # Check end zones
        if end_zones:
            for zone_idx, zone in enumerate(end_zones):
                if _identify_zone(x, z, zone):
                    node_idx = len(junctions) + len(start_zones) + zone_idx
                    nodes_at_this_point.append(node_idx)
        
        # If we&#39;re in any nodes at this point, select the first one we encounter
        # (this maintains temporal order - first node reached along the path)
        if nodes_at_this_point:
            # Use the first node in the list (maintains order of checking)
            closest_node = nodes_at_this_point[0]
            
            # Add node to sequence if it&#39;s different from current node
            if closest_node != current_node:
                sequence.append(closest_node)
                current_node = closest_node
        else:
            # Not in any node
            current_node = None
    
    # Special handling for start zones: if trajectory starts in a start zone,
    # ensure it&#39;s the first node in the sequence
    if start_zones and len(trajectory.x) &gt; 0:
        first_x, first_z = trajectory.x[0], trajectory.z[0]
        for zone_idx, zone in enumerate(start_zones):
            if _identify_zone(first_x, first_z, zone):
                node_idx = len(junctions) + zone_idx
                # If sequence doesn&#39;t start with this start zone, prepend it
                if not sequence or sequence[0] != node_idx:
                    sequence.insert(0, node_idx)
                break
    
    # Special handling for end zones: if trajectory ends in an end zone,
    # ensure it&#39;s the last node in the sequence
    if end_zones and len(trajectory.x) &gt; 0:
        last_x, last_z = trajectory.x[-1], trajectory.z[-1]
        for zone_idx, zone in enumerate(end_zones):
            if _identify_zone(last_x, last_z, zone):
                node_idx = len(junctions) + len(start_zones) + zone_idx
                # If sequence doesn&#39;t end with this end zone, append it
                if not sequence or sequence[-1] != node_idx:
                    sequence.append(node_idx)
                break
    
    return sequence


def _identify_zone(x: float, z: float, zone: Dict[str, Any]) -&gt; bool:
    &#34;&#34;&#34;
    Check if a point is within a zone (circular or rectangular).
    
    Args:
        x, z: Point coordinates
        zone: Zone definition dictionary
        
    Returns:
        True if point is within zone (including proximity tolerance)
    &#34;&#34;&#34;
    proximity_tolerance = zone.get(&#39;proximity_tolerance&#39;, 0)
    
    if zone[&#39;type&#39;] == &#39;circle&#39;:
        center_x = zone[&#39;center_x&#39;]
        center_z = zone[&#39;center_z&#39;]
        radius = zone[&#39;radius&#39;]
        
        distance = np.sqrt((x - center_x)**2 + (z - center_z)**2)
        return distance &lt;= (radius + proximity_tolerance)
    
    elif zone[&#39;type&#39;] == &#39;rectangle&#39;:
        # Handle GUI format (x_min, x_max, z_min, z_max)
        x_min, x_max = zone[&#39;x_min&#39;], zone[&#39;x_max&#39;]
        z_min, z_max = zone[&#39;z_min&#39;], zone[&#39;z_max&#39;]
        
        tilt = zone.get(&#39;tilt&#39;, 0)
        
        # Apply inverse rotation if tilted
        if tilt != 0:
            cos_tilt = np.cos(-np.radians(tilt))
            sin_tilt = np.sin(-np.radians(tilt))
            
            # Translate to origin
            x_rel = x - (x_min + x_max) / 2
            z_rel = z - (z_min + z_max) / 2
            
            # Apply inverse rotation
            x_rot = x_rel * cos_tilt - z_rel * sin_tilt
            z_rot = x_rel * sin_tilt + z_rel * cos_tilt
            
            # Translate back
            x = x_rot + (x_min + x_max) / 2
            z = z_rot + (z_min + z_max) / 2
        
def plot_chain_overview(trajectories: List[Trajectory], chain_df: pd.DataFrame, junctions: List[Circle], 
                       r_outer_list: Optional[List[float]] = None, path_length: float = 100.0, 
                       epsilon: float = 0.015, linger_delta: float = 5.0, decision_mode: str = &#34;hybrid&#34;,
                       out_path: str = &#34;Chain_Overview.png&#34;, show_paths: bool = True, 
                       show_centers: bool = False, centers_list: Optional[List[np.ndarray]] = None,
                       annotate_counts: bool = False):
    &#34;&#34;&#34;
    Plot an overview of the decision chain analysis showing all junctions and trajectories.
    
    Args:
        trajectories: List of trajectory objects
        chain_df: DataFrame with chain analysis results
        junctions: List of junction Circle objects
        r_outer_list: Optional list of outer radii for each junction
        path_length: Path length for decision analysis
        epsilon: Minimum step size
        linger_delta: Linger distance beyond junction
        decision_mode: Decision mode (&#34;pathlen&#34;, &#34;radial&#34;, &#34;hybrid&#34;)
        out_path: Output file path
        show_paths: Whether to show trajectory paths
        show_centers: Whether to show branch centers
        centers_list: Optional list of branch centers for each junction
        annotate_counts: Whether to annotate branch counts
    &#34;&#34;&#34;
    fig, ax = plt.subplots(figsize=DEFAULT_PLOT_CONFIG.figsize, dpi=DEFAULT_PLOT_CONFIG.dpi)
    
    # Plot trajectories
    if show_paths:
        for traj in trajectories:
            ax.plot(traj.x, traj.z, &#39;b-&#39;, alpha=0.3, linewidth=0.5)
    
    # Plot junctions
    for i, junction in enumerate(junctions):
        # Main junction circle
        circle = plt.Circle((junction.cx, junction.cz), junction.r, 
                          color=&#39;red&#39;, alpha=0.3, edgecolor=&#39;red&#39;, linewidth=2)
        ax.add_patch(circle)
        
        # Outer radius if available
        if r_outer_list and i &lt; len(r_outer_list) and r_outer_list[i] is not None:
            outer_circle = plt.Circle((junction.cx, junction.cz), r_outer_list[i], 
                                    color=&#39;red&#39;, alpha=0.1, edgecolor=&#39;red&#39;, linewidth=1, linestyle=&#39;--&#39;)
            ax.add_patch(outer_circle)
        
        # Junction label
        ax.text(junction.cx, junction.cz, f&#39;J{i}&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, 
                fontsize=DEFAULT_PLOT_CONFIG.fontsize, fontweight=&#39;bold&#39;, color=&#39;red&#39;)
    
    # Plot branch centers if available
    if show_centers and centers_list:
        for i, centers in enumerate(centers_list):
            if centers is not None and len(centers) &gt; 0:
                junction = junctions[i]
                for j, center in enumerate(centers):
                    ax.plot(center[0], center[1], &#39;o&#39;, color=DEFAULT_PLOT_CONFIG.get_branch_color(j), 
                           markersize=8, markeredgecolor=&#39;black&#39;, markeredgewidth=1)
                    if annotate_counts:
                        ax.text(center[0], center[1], f&#39;B{j}&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, 
                               fontsize=8, fontweight=&#39;bold&#39;)
    
    ax.set_xlabel(&#39;X Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
    ax.set_ylabel(&#39;Z Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
    ax.set_title(&#39;Decision Chain Overview&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize)
    ax.grid(True, alpha=DEFAULT_PLOT_CONFIG.grid_alpha)
    ax.set_aspect(&#39;equal&#39;)
    
    DEFAULT_PLOT_CONFIG.apply_to_figure(fig)
    plt.savefig(out_path, dpi=DEFAULT_PLOT_CONFIG.dpi, bbox_inches=&#39;tight&#39;)
    plt.close()


def plot_chain_small_multiples(trajectories: List[Trajectory], chain_df: pd.DataFrame, junctions: List[Circle],
                              r_outer_list: Optional[List[float]] = None, window_radius: float = 80.0,
                              path_length: float = 100.0, epsilon: float = 0.015, linger_delta: float = 5.0,
                              decision_mode: str = &#34;hybrid&#34;, out_path: str = &#34;Chain_SmallMultiples.png&#34;,
                              centers_list: Optional[List[np.ndarray]] = None, decisions_df: Optional[pd.DataFrame] = None):
    &#34;&#34;&#34;
    Plot small multiples showing trajectory patterns around each junction with branch coloring and intercepts.
    
    Args:
        trajectories: List of trajectory objects
        chain_df: DataFrame with chain analysis results
        junctions: List of junction Circle objects
        r_outer_list: Optional list of outer radii for each junction
        window_radius: Radius of the window around each junction
        path_length: Path length for decision analysis
        epsilon: Minimum step size
        linger_delta: Linger distance beyond junction
        decision_mode: Decision mode (&#34;pathlen&#34;, &#34;radial&#34;, &#34;hybrid&#34;)
        out_path: Output file path
        centers_list: Optional list of branch centers for each junction
        decisions_df: DataFrame with decision points (intercept_x, intercept_z, trajectory, junction_idx)
    &#34;&#34;&#34;
    n_junctions = len(junctions)
    if n_junctions == 0:
        return
    
    # Debug: Print chain_df info
    print(f&#34;DEBUG: chain_df shape: {chain_df.shape}&#34;)
    print(f&#34;DEBUG: chain_df columns: {list(chain_df.columns)}&#34;)
    print(f&#34;DEBUG: centers_list length: {len(centers_list) if centers_list else &#39;None&#39;}&#34;)
    
    # Calculate grid layout
    cols = min(3, n_junctions)  # Max 3 columns
    rows = (n_junctions + cols - 1) // cols
    
    fig, axes = plt.subplots(rows, cols, figsize=(cols * 6, rows * 6), dpi=DEFAULT_PLOT_CONFIG.dpi)
    if n_junctions == 1:
        axes = [axes]
    elif rows == 1:
        axes = axes if isinstance(axes, list) else [axes]
    else:
        axes = axes.flatten()
    
    for i, junction in enumerate(junctions):
        ax = axes[i] if i &lt; len(axes) else None
        if ax is None:
            continue
            
        # Set window bounds
        x_min, x_max = junction.cx - window_radius, junction.cx + window_radius
        z_min, z_max = junction.cz - window_radius, junction.cz + window_radius
        
        # Get branch assignments for this junction
        branch_col = f&#34;branch_j{i}&#34;
        print(f&#34;DEBUG: Looking for column &#39;{branch_col}&#39; in chain_df&#34;)
        
        if branch_col in chain_df.columns:
            print(f&#34;DEBUG: Found column &#39;{branch_col}&#39;, unique values: {chain_df[branch_col].unique()}&#34;)
            
            # Create trajectory to branch mapping
            traj_branches = {}
            for _, row in chain_df.iterrows():
                traj_id = row.get(&#39;trajectory&#39;, 0)
                branch = row.get(branch_col)
                if pd.notna(branch) and branch &gt;= 0:  # Only valid branches
                    traj_branches[traj_id] = int(branch)
            
            print(f&#34;DEBUG: Junction {i} - traj_branches: {len(traj_branches)} trajectories assigned&#34;)
            
            # Plot trajectories colored by branch
            branch_colors = {}
            for traj_idx, traj in enumerate(trajectories):
                branch = traj_branches.get(traj_idx, -1)
                if branch &gt;= 0:  # Valid branch
                    if branch not in branch_colors:
                        branch_colors[branch] = DEFAULT_PLOT_CONFIG.get_branch_color(branch)
                    
                    # Filter trajectory points within window
                    mask = ((traj.x &gt;= x_min) &amp; (traj.x &lt;= x_max) &amp; 
                           (traj.z &gt;= z_min) &amp; (traj.z &lt;= z_max))
                    if np.any(mask):
                        ax.plot(traj.x[mask], traj.z[mask], color=branch_colors[branch], 
                               alpha=0.6, linewidth=1)
            
            print(f&#34;DEBUG: Junction {i} - branch_colors: {branch_colors}&#34;)
            
            # Plot decision intercepts using the same logic as plot_decision_intercepts
            if centers_list and i &lt; len(centers_list) and centers_list[i] is not None:
                centers = centers_list[i]
                r_outer = r_outer_list[i] if r_outer_list and i &lt; len(r_outer_list) else junction.r * 2
                
                print(f&#34;DEBUG: Junction {i} - centers shape: {centers.shape if hasattr(centers, &#39;shape&#39;) else &#39;No shape&#39;}&#34;)
                print(f&#34;DEBUG: Junction {i} - r_outer: {r_outer}&#34;)
                
                # Create assignments DataFrame for this junction
                junction_assignments = chain_df[[&#39;trajectory&#39;, branch_col]].copy()
                junction_assignments = junction_assignments.rename(columns={branch_col: &#39;branch&#39;})
                junction_assignments = junction_assignments[junction_assignments[&#39;branch&#39;] &gt;= 0]
                
                print(f&#34;DEBUG: Junction {i} - junction_assignments shape: {junction_assignments.shape}&#34;)
                
                if len(junction_assignments) &gt; 0:
                    # Plot decision intercepts for each branch
                    for branch_idx, center in enumerate(centers):
                        if branch_idx in branch_colors:
                            color = branch_colors[branch_idx]
                            
                            # Get trajectories for this branch
                            branch_trajectories = junction_assignments[junction_assignments[&#39;branch&#39;] == branch_idx]
                            
                            print(f&#34;DEBUG: Junction {i}, Branch {branch_idx} - {len(branch_trajectories)} trajectories&#34;)
                            
                            # For each trajectory in this branch, find where it intersects the outer radius
                            for _, row in branch_trajectories.iterrows():
                                traj_id = row[&#39;trajectory&#39;]
                                if traj_id &lt; len(trajectories):
                                    traj = trajectories[traj_id]
                                    
                                    # Find intersection with outer radius circle
                                    # Calculate distance from junction center for each point
                                    distances = np.sqrt((traj.x - junction.cx)**2 + (traj.z - junction.cz)**2)
                                    
                                    # Find points near the outer radius
                                    radius_tolerance = 5.0  # Tolerance for intersection detection
                                    near_radius = np.abs(distances - r_outer) &lt; radius_tolerance
                                    
                                    if np.any(near_radius):
                                        # Get the first point that&#39;s near the outer radius
                                        intersect_idx = np.where(near_radius)[0][0]
                                        intersect_x = traj.x[intersect_idx]
                                        intersect_z = traj.z[intersect_idx]
                                        
                                        # Only plot if within window
                                        if (x_min &lt;= intersect_x &lt;= x_max and z_min &lt;= intersect_z &lt;= z_max):
                                            ax.plot(intersect_x, intersect_z, &#39;o&#39;, color=color, 
                                                   markersize=4, markeredgecolor=&#39;black&#39;, markeredgewidth=0.5)
            else:
                print(f&#34;DEBUG: Junction {i} - No centers_list or centers is None&#34;)
            
            # Create legend for branches
            if branch_colors:
                legend_elements = []
                for branch in sorted(branch_colors.keys()):
                    legend_elements.append(plt.Line2D([0], [0], color=branch_colors[branch], 
                                                    label=f&#39;Branch {branch}&#39;))
                ax.legend(handles=legend_elements, loc=&#39;upper right&#39;, fontsize=8)
        else:
            print(f&#34;DEBUG: Column &#39;{branch_col}&#39; not found in chain_df&#34;)
            # Fallback: plot all trajectories in blue if no branch data
            for traj in trajectories:
                mask = ((traj.x &gt;= x_min) &amp; (traj.x &lt;= x_max) &amp; 
                       (traj.z &gt;= z_min) &amp; (traj.z &lt;= z_max))
                if np.any(mask):
                    ax.plot(traj.x[mask], traj.z[mask], &#39;b-&#39;, alpha=0.6, linewidth=1)
        
        # Plot junction
        circle = plt.Circle((junction.cx, junction.cz), junction.r, 
                          color=&#39;black&#39;, alpha=0.8, edgecolor=&#39;black&#39;, linewidth=2)
        ax.add_patch(circle)
        
        # Plot outer radius if available
        if r_outer_list and i &lt; len(r_outer_list) and r_outer_list[i] is not None:
            outer_circle = plt.Circle((junction.cx, junction.cz), r_outer_list[i], 
                                    color=&#39;orange&#39;, alpha=0.3, edgecolor=&#39;orange&#39;, linewidth=2)
            ax.add_patch(outer_circle)
        
        # Add junction center dot
        ax.plot(junction.cx, junction.cz, &#39;ko&#39;, markersize=3)
        
        # Count intercepts for title
        intercept_count = 0
        if branch_col in chain_df.columns:
            intercept_count = len(chain_df[chain_df[branch_col] &gt;= 0])
        
        # Set axis properties
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(z_min, z_max)
        ax.set_xlabel(&#39;X Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
        ax.set_ylabel(&#39;Z Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
        ax.set_title(f&#39;J{i} ({intercept_count} intercepts)&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize)
        ax.grid(True, alpha=DEFAULT_PLOT_CONFIG.grid_alpha)
        ax.set_aspect(&#39;equal&#39;)
    
    # Hide unused subplots
    for i in range(n_junctions, len(axes)):
        axes[i].set_visible(False)
    
    plt.suptitle(&#39;Decision Chain Small Multiples&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize + 2)
    DEFAULT_PLOT_CONFIG.apply_to_figure(fig)
    plt.savefig(out_path, dpi=DEFAULT_PLOT_CONFIG.dpi, bbox_inches=&#39;tight&#39;)
    plt.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="verta.verta_plotting.plot_chain_overview"><code class="name flex">
<span>def <span class="ident">plot_chain_overview</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>], chain_df: pandas.core.frame.DataFrame, junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>], r_outer_list: Optional[List[float]] = None, path_length: float = 100.0, epsilon: float = 0.015, linger_delta: float = 5.0, decision_mode: str = 'hybrid', out_path: str = 'Chain_Overview.png', show_paths: bool = True, show_centers: bool = False, centers_list: Optional[List[numpy.ndarray]] = None, annotate_counts: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot an overview of the decision chain analysis showing all junctions and trajectories.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with chain analysis results</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of junction Circle objects</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>Optional list of outer radii for each junction</dd>
<dt><strong><code>path_length</code></strong></dt>
<dd>Path length for decision analysis</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Minimum step size</dd>
<dt><strong><code>linger_delta</code></strong></dt>
<dd>Linger distance beyond junction</dd>
<dt><strong><code>decision_mode</code></strong></dt>
<dd>Decision mode ("pathlen", "radial", "hybrid")</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Output file path</dd>
<dt><strong><code>show_paths</code></strong></dt>
<dd>Whether to show trajectory paths</dd>
<dt><strong><code>show_centers</code></strong></dt>
<dd>Whether to show branch centers</dd>
<dt><strong><code>centers_list</code></strong></dt>
<dd>Optional list of branch centers for each junction</dd>
<dt><strong><code>annotate_counts</code></strong></dt>
<dd>Whether to annotate branch counts</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_chain_overview(trajectories: List[Trajectory], chain_df: pd.DataFrame, junctions: List[Circle], 
                       r_outer_list: Optional[List[float]] = None, path_length: float = 100.0, 
                       epsilon: float = 0.015, linger_delta: float = 5.0, decision_mode: str = &#34;hybrid&#34;,
                       out_path: str = &#34;Chain_Overview.png&#34;, show_paths: bool = True, 
                       show_centers: bool = False, centers_list: Optional[List[np.ndarray]] = None,
                       annotate_counts: bool = False):
    &#34;&#34;&#34;
    Plot an overview of the decision chain analysis showing all junctions and trajectories.
    
    Args:
        trajectories: List of trajectory objects
        chain_df: DataFrame with chain analysis results
        junctions: List of junction Circle objects
        r_outer_list: Optional list of outer radii for each junction
        path_length: Path length for decision analysis
        epsilon: Minimum step size
        linger_delta: Linger distance beyond junction
        decision_mode: Decision mode (&#34;pathlen&#34;, &#34;radial&#34;, &#34;hybrid&#34;)
        out_path: Output file path
        show_paths: Whether to show trajectory paths
        show_centers: Whether to show branch centers
        centers_list: Optional list of branch centers for each junction
        annotate_counts: Whether to annotate branch counts
    &#34;&#34;&#34;
    fig, ax = plt.subplots(figsize=DEFAULT_PLOT_CONFIG.figsize, dpi=DEFAULT_PLOT_CONFIG.dpi)
    
    # Plot trajectories
    if show_paths:
        for traj in trajectories:
            ax.plot(traj.x, traj.z, &#39;b-&#39;, alpha=0.3, linewidth=0.5)
    
    # Plot junctions
    for i, junction in enumerate(junctions):
        # Main junction circle
        circle = plt.Circle((junction.cx, junction.cz), junction.r, 
                          color=&#39;red&#39;, alpha=0.3, edgecolor=&#39;red&#39;, linewidth=2)
        ax.add_patch(circle)
        
        # Outer radius if available
        if r_outer_list and i &lt; len(r_outer_list) and r_outer_list[i] is not None:
            outer_circle = plt.Circle((junction.cx, junction.cz), r_outer_list[i], 
                                    color=&#39;red&#39;, alpha=0.1, edgecolor=&#39;red&#39;, linewidth=1, linestyle=&#39;--&#39;)
            ax.add_patch(outer_circle)
        
        # Junction label
        ax.text(junction.cx, junction.cz, f&#39;J{i}&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, 
                fontsize=DEFAULT_PLOT_CONFIG.fontsize, fontweight=&#39;bold&#39;, color=&#39;red&#39;)
    
    # Plot branch centers if available
    if show_centers and centers_list:
        for i, centers in enumerate(centers_list):
            if centers is not None and len(centers) &gt; 0:
                junction = junctions[i]
                for j, center in enumerate(centers):
                    ax.plot(center[0], center[1], &#39;o&#39;, color=DEFAULT_PLOT_CONFIG.get_branch_color(j), 
                           markersize=8, markeredgecolor=&#39;black&#39;, markeredgewidth=1)
                    if annotate_counts:
                        ax.text(center[0], center[1], f&#39;B{j}&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, 
                               fontsize=8, fontweight=&#39;bold&#39;)
    
    ax.set_xlabel(&#39;X Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
    ax.set_ylabel(&#39;Z Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
    ax.set_title(&#39;Decision Chain Overview&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize)
    ax.grid(True, alpha=DEFAULT_PLOT_CONFIG.grid_alpha)
    ax.set_aspect(&#39;equal&#39;)
    
    DEFAULT_PLOT_CONFIG.apply_to_figure(fig)
    plt.savefig(out_path, dpi=DEFAULT_PLOT_CONFIG.dpi, bbox_inches=&#39;tight&#39;)
    plt.close()</code></pre>
</details>
</dd>
<dt id="verta.verta_plotting.plot_chain_small_multiples"><code class="name flex">
<span>def <span class="ident">plot_chain_small_multiples</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>], chain_df: pandas.core.frame.DataFrame, junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>], r_outer_list: Optional[List[float]] = None, window_radius: float = 80.0, path_length: float = 100.0, epsilon: float = 0.015, linger_delta: float = 5.0, decision_mode: str = 'hybrid', out_path: str = 'Chain_SmallMultiples.png', centers_list: Optional[List[numpy.ndarray]] = None, decisions_df: Optional[pandas.core.frame.DataFrame] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot small multiples showing trajectory patterns around each junction with branch coloring and intercepts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with chain analysis results</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of junction Circle objects</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>Optional list of outer radii for each junction</dd>
<dt><strong><code>window_radius</code></strong></dt>
<dd>Radius of the window around each junction</dd>
<dt><strong><code>path_length</code></strong></dt>
<dd>Path length for decision analysis</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Minimum step size</dd>
<dt><strong><code>linger_delta</code></strong></dt>
<dd>Linger distance beyond junction</dd>
<dt><strong><code>decision_mode</code></strong></dt>
<dd>Decision mode ("pathlen", "radial", "hybrid")</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Output file path</dd>
<dt><strong><code>centers_list</code></strong></dt>
<dd>Optional list of branch centers for each junction</dd>
<dt><strong><code>decisions_df</code></strong></dt>
<dd>DataFrame with decision points (intercept_x, intercept_z, trajectory, junction_idx)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_chain_small_multiples(trajectories: List[Trajectory], chain_df: pd.DataFrame, junctions: List[Circle],
                              r_outer_list: Optional[List[float]] = None, window_radius: float = 80.0,
                              path_length: float = 100.0, epsilon: float = 0.015, linger_delta: float = 5.0,
                              decision_mode: str = &#34;hybrid&#34;, out_path: str = &#34;Chain_SmallMultiples.png&#34;,
                              centers_list: Optional[List[np.ndarray]] = None, decisions_df: Optional[pd.DataFrame] = None):
    &#34;&#34;&#34;
    Plot small multiples showing trajectory patterns around each junction with branch coloring and intercepts.
    
    Args:
        trajectories: List of trajectory objects
        chain_df: DataFrame with chain analysis results
        junctions: List of junction Circle objects
        r_outer_list: Optional list of outer radii for each junction
        window_radius: Radius of the window around each junction
        path_length: Path length for decision analysis
        epsilon: Minimum step size
        linger_delta: Linger distance beyond junction
        decision_mode: Decision mode (&#34;pathlen&#34;, &#34;radial&#34;, &#34;hybrid&#34;)
        out_path: Output file path
        centers_list: Optional list of branch centers for each junction
        decisions_df: DataFrame with decision points (intercept_x, intercept_z, trajectory, junction_idx)
    &#34;&#34;&#34;
    n_junctions = len(junctions)
    if n_junctions == 0:
        return
    
    # Debug: Print chain_df info
    print(f&#34;DEBUG: chain_df shape: {chain_df.shape}&#34;)
    print(f&#34;DEBUG: chain_df columns: {list(chain_df.columns)}&#34;)
    print(f&#34;DEBUG: centers_list length: {len(centers_list) if centers_list else &#39;None&#39;}&#34;)
    
    # Calculate grid layout
    cols = min(3, n_junctions)  # Max 3 columns
    rows = (n_junctions + cols - 1) // cols
    
    fig, axes = plt.subplots(rows, cols, figsize=(cols * 6, rows * 6), dpi=DEFAULT_PLOT_CONFIG.dpi)
    if n_junctions == 1:
        axes = [axes]
    elif rows == 1:
        axes = axes if isinstance(axes, list) else [axes]
    else:
        axes = axes.flatten()
    
    for i, junction in enumerate(junctions):
        ax = axes[i] if i &lt; len(axes) else None
        if ax is None:
            continue
            
        # Set window bounds
        x_min, x_max = junction.cx - window_radius, junction.cx + window_radius
        z_min, z_max = junction.cz - window_radius, junction.cz + window_radius
        
        # Get branch assignments for this junction
        branch_col = f&#34;branch_j{i}&#34;
        print(f&#34;DEBUG: Looking for column &#39;{branch_col}&#39; in chain_df&#34;)
        
        if branch_col in chain_df.columns:
            print(f&#34;DEBUG: Found column &#39;{branch_col}&#39;, unique values: {chain_df[branch_col].unique()}&#34;)
            
            # Create trajectory to branch mapping
            traj_branches = {}
            for _, row in chain_df.iterrows():
                traj_id = row.get(&#39;trajectory&#39;, 0)
                branch = row.get(branch_col)
                if pd.notna(branch) and branch &gt;= 0:  # Only valid branches
                    traj_branches[traj_id] = int(branch)
            
            print(f&#34;DEBUG: Junction {i} - traj_branches: {len(traj_branches)} trajectories assigned&#34;)
            
            # Plot trajectories colored by branch
            branch_colors = {}
            for traj_idx, traj in enumerate(trajectories):
                branch = traj_branches.get(traj_idx, -1)
                if branch &gt;= 0:  # Valid branch
                    if branch not in branch_colors:
                        branch_colors[branch] = DEFAULT_PLOT_CONFIG.get_branch_color(branch)
                    
                    # Filter trajectory points within window
                    mask = ((traj.x &gt;= x_min) &amp; (traj.x &lt;= x_max) &amp; 
                           (traj.z &gt;= z_min) &amp; (traj.z &lt;= z_max))
                    if np.any(mask):
                        ax.plot(traj.x[mask], traj.z[mask], color=branch_colors[branch], 
                               alpha=0.6, linewidth=1)
            
            print(f&#34;DEBUG: Junction {i} - branch_colors: {branch_colors}&#34;)
            
            # Plot decision intercepts using the same logic as plot_decision_intercepts
            if centers_list and i &lt; len(centers_list) and centers_list[i] is not None:
                centers = centers_list[i]
                r_outer = r_outer_list[i] if r_outer_list and i &lt; len(r_outer_list) else junction.r * 2
                
                print(f&#34;DEBUG: Junction {i} - centers shape: {centers.shape if hasattr(centers, &#39;shape&#39;) else &#39;No shape&#39;}&#34;)
                print(f&#34;DEBUG: Junction {i} - r_outer: {r_outer}&#34;)
                
                # Create assignments DataFrame for this junction
                junction_assignments = chain_df[[&#39;trajectory&#39;, branch_col]].copy()
                junction_assignments = junction_assignments.rename(columns={branch_col: &#39;branch&#39;})
                junction_assignments = junction_assignments[junction_assignments[&#39;branch&#39;] &gt;= 0]
                
                print(f&#34;DEBUG: Junction {i} - junction_assignments shape: {junction_assignments.shape}&#34;)
                
                if len(junction_assignments) &gt; 0:
                    # Plot decision intercepts for each branch
                    for branch_idx, center in enumerate(centers):
                        if branch_idx in branch_colors:
                            color = branch_colors[branch_idx]
                            
                            # Get trajectories for this branch
                            branch_trajectories = junction_assignments[junction_assignments[&#39;branch&#39;] == branch_idx]
                            
                            print(f&#34;DEBUG: Junction {i}, Branch {branch_idx} - {len(branch_trajectories)} trajectories&#34;)
                            
                            # For each trajectory in this branch, find where it intersects the outer radius
                            for _, row in branch_trajectories.iterrows():
                                traj_id = row[&#39;trajectory&#39;]
                                if traj_id &lt; len(trajectories):
                                    traj = trajectories[traj_id]
                                    
                                    # Find intersection with outer radius circle
                                    # Calculate distance from junction center for each point
                                    distances = np.sqrt((traj.x - junction.cx)**2 + (traj.z - junction.cz)**2)
                                    
                                    # Find points near the outer radius
                                    radius_tolerance = 5.0  # Tolerance for intersection detection
                                    near_radius = np.abs(distances - r_outer) &lt; radius_tolerance
                                    
                                    if np.any(near_radius):
                                        # Get the first point that&#39;s near the outer radius
                                        intersect_idx = np.where(near_radius)[0][0]
                                        intersect_x = traj.x[intersect_idx]
                                        intersect_z = traj.z[intersect_idx]
                                        
                                        # Only plot if within window
                                        if (x_min &lt;= intersect_x &lt;= x_max and z_min &lt;= intersect_z &lt;= z_max):
                                            ax.plot(intersect_x, intersect_z, &#39;o&#39;, color=color, 
                                                   markersize=4, markeredgecolor=&#39;black&#39;, markeredgewidth=0.5)
            else:
                print(f&#34;DEBUG: Junction {i} - No centers_list or centers is None&#34;)
            
            # Create legend for branches
            if branch_colors:
                legend_elements = []
                for branch in sorted(branch_colors.keys()):
                    legend_elements.append(plt.Line2D([0], [0], color=branch_colors[branch], 
                                                    label=f&#39;Branch {branch}&#39;))
                ax.legend(handles=legend_elements, loc=&#39;upper right&#39;, fontsize=8)
        else:
            print(f&#34;DEBUG: Column &#39;{branch_col}&#39; not found in chain_df&#34;)
            # Fallback: plot all trajectories in blue if no branch data
            for traj in trajectories:
                mask = ((traj.x &gt;= x_min) &amp; (traj.x &lt;= x_max) &amp; 
                       (traj.z &gt;= z_min) &amp; (traj.z &lt;= z_max))
                if np.any(mask):
                    ax.plot(traj.x[mask], traj.z[mask], &#39;b-&#39;, alpha=0.6, linewidth=1)
        
        # Plot junction
        circle = plt.Circle((junction.cx, junction.cz), junction.r, 
                          color=&#39;black&#39;, alpha=0.8, edgecolor=&#39;black&#39;, linewidth=2)
        ax.add_patch(circle)
        
        # Plot outer radius if available
        if r_outer_list and i &lt; len(r_outer_list) and r_outer_list[i] is not None:
            outer_circle = plt.Circle((junction.cx, junction.cz), r_outer_list[i], 
                                    color=&#39;orange&#39;, alpha=0.3, edgecolor=&#39;orange&#39;, linewidth=2)
            ax.add_patch(outer_circle)
        
        # Add junction center dot
        ax.plot(junction.cx, junction.cz, &#39;ko&#39;, markersize=3)
        
        # Count intercepts for title
        intercept_count = 0
        if branch_col in chain_df.columns:
            intercept_count = len(chain_df[chain_df[branch_col] &gt;= 0])
        
        # Set axis properties
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(z_min, z_max)
        ax.set_xlabel(&#39;X Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
        ax.set_ylabel(&#39;Z Position&#39;, fontsize=DEFAULT_PLOT_CONFIG.label_fontsize)
        ax.set_title(f&#39;J{i} ({intercept_count} intercepts)&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize)
        ax.grid(True, alpha=DEFAULT_PLOT_CONFIG.grid_alpha)
        ax.set_aspect(&#39;equal&#39;)
    
    # Hide unused subplots
    for i in range(n_junctions, len(axes)):
        axes[i].set_visible(False)
    
    plt.suptitle(&#39;Decision Chain Small Multiples&#39;, fontsize=DEFAULT_PLOT_CONFIG.title_fontsize + 2)
    DEFAULT_PLOT_CONFIG.apply_to_figure(fig)
    plt.savefig(out_path, dpi=DEFAULT_PLOT_CONFIG.dpi, bbox_inches=&#39;tight&#39;)
    plt.close()</code></pre>
</details>
</dd>
<dt id="verta.verta_plotting.plot_decision_intercepts"><code class="name flex">
<span>def <span class="ident">plot_decision_intercepts</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>], assignments_df: pandas.core.frame.DataFrame, mode_log_df: pandas.core.frame.DataFrame, centers: numpy.ndarray, junction: <a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>, r_outer: float, path_length: float, epsilon: float, linger_delta: float, *, out_path: str = 'Decision_Intercepts.png', show_paths: bool = True, legend_noenter_as_line: bool = False, junction_number: int = 0, all_junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>] = None, decision_points_df: pandas.core.frame.DataFrame = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plot decision intercepts for a junction with branch analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of Trajectory objects</dd>
<dt><strong><code>assignments_df</code></strong></dt>
<dd>DataFrame with trajectory assignments</dd>
<dt><strong><code>mode_log_df</code></strong></dt>
<dd>DataFrame with mode information</dd>
<dt><strong><code>centers</code></strong></dt>
<dd>Array of cluster centers</dd>
<dt><strong><code>junction</code></strong></dt>
<dd>Junction circle</dd>
<dt><strong><code>r_outer</code></strong></dt>
<dd>Outer radius for analysis</dd>
<dt><strong><code>path_length</code></strong></dt>
<dd>Path length threshold</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Epsilon parameter</dd>
<dt><strong><code>linger_delta</code></strong></dt>
<dd>Linger delta parameter</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Output path for the plot</dd>
<dt><strong><code>show_paths</code></strong></dt>
<dd>Whether to show trajectory paths</dd>
<dt><strong><code>legend_noenter_as_line</code></strong></dt>
<dd>Whether to show no-entry as line in legend</dd>
<dt><strong><code>junction_number</code></strong></dt>
<dd>Junction number for title</dd>
<dt><strong><code>all_junctions</code></strong></dt>
<dd>List of all junctions for mini-map</dd>
<dt><strong><code>decision_points_df</code></strong></dt>
<dd>DataFrame with actual decision point coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_decision_intercepts(
    trajectories: List[Trajectory],
    assignments_df: pd.DataFrame,
    mode_log_df: pd.DataFrame,
    centers: np.ndarray,
    junction: Circle,
    r_outer: float,
    path_length: float,
    epsilon: float,
    linger_delta: float,
    *,
    out_path: str = &#34;Decision_Intercepts.png&#34;,
    show_paths: bool = True,
    legend_noenter_as_line: bool = False,
    junction_number: int = 0,
    all_junctions: List[Circle] = None,
    decision_points_df: pd.DataFrame = None
) -&gt; None:
    &#34;&#34;&#34;Plot decision intercepts for a junction with branch analysis.
    
    Args:
        trajectories: List of Trajectory objects
        assignments_df: DataFrame with trajectory assignments
        mode_log_df: DataFrame with mode information
        centers: Array of cluster centers
        junction: Junction circle
        r_outer: Outer radius for analysis
        path_length: Path length threshold
        epsilon: Epsilon parameter
        linger_delta: Linger delta parameter
        out_path: Output path for the plot
        show_paths: Whether to show trajectory paths
        legend_noenter_as_line: Whether to show no-entry as line in legend
        junction_number: Junction number for title
        all_junctions: List of all junctions for mini-map
        decision_points_df: DataFrame with actual decision point coordinates
    &#34;&#34;&#34;
    # Create a more comprehensive layout with heading and mini-map
    fig = plt.figure(figsize=(16, 12))
    
    # Create a grid layout: heading at top, main plot in center, mini-map at bottom
    gs = fig.add_gridspec(3, 1, height_ratios=[0.5, 3, 1], hspace=0.3)
    
    # Add heading
    ax_title = fig.add_subplot(gs[0])
    ax_title.text(0.5, 0.5, f&#39;Junction {junction_number} - Decision Intercepts Analysis&#39;, 
                  ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=16, fontweight=&#39;bold&#39;)
    ax_title.set_xlim(0, 1)
    ax_title.set_ylim(0, 1)
    ax_title.axis(&#39;off&#39;)
    
    # Main plot
    ax = fig.add_subplot(gs[1])
    
    # Plot trajectories if requested
    if show_paths:
        for tr in trajectories:
            ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.5, alpha=0.3)
    
    # Plot junction
    theta = np.linspace(0, 2*np.pi, 100)
    junction_x = junction.cx + junction.r * np.cos(theta)
    junction_z = junction.cz + junction.r * np.sin(theta)
    ax.plot(junction_x, junction_z, &#39;k-&#39;, linewidth=2, label=&#39;Junction&#39;)
    
    # Plot outer radius
    outer_x = junction.cx + r_outer * np.cos(theta)
    outer_z = junction.cz + r_outer * np.sin(theta)
    ax.plot(outer_x, outer_z, &#39;orange&#39;, linewidth=1, alpha=0.7, label=&#39;Analysis Radius&#39;)
    
    # Plot junction center
    ax.scatter([junction.cx], [junction.cz], c=&#39;black&#39;, s=50, marker=&#39;o&#39;, 
              label=&#39;Junction Center&#39;)
    
    # Plot branch analysis with triangular markers and connections
    if len(centers) &gt; 0 and assignments_df is not None:
        # Define colors and markers for different branches
        colors = [&#39;blue&#39;, &#39;orange&#39;, &#39;green&#39;, &#39;red&#39;, &#39;purple&#39;, &#39;brown&#39;, &#39;pink&#39;, &#39;gray&#39;]
        markers = [&#39;^&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;v&#39;, &#39;s&#39;, &#39;D&#39;, &#39;o&#39;, &#39;h&#39;]
        
        # Calculate branch statistics
        branch_counts = assignments_df[&#39;branch&#39;].value_counts().sort_index()
        total_trajectories = len(assignments_df)
        
        # Plot branch markers and directions
        for i, center in enumerate(centers):
            color = colors[i % len(colors)]
            marker = markers[i % len(markers)]
            
            # Get assignments for this branch
            branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
            branch_count = len(branch_assignments)
            
            if branch_count &gt; 0:
                # Calculate branch direction from actual decision points if available
                if decision_points_df is not None and len(decision_points_df) &gt; 0:
                    # Merge decision points with assignments to get actual coordinates
                    assignments_df_copy = assignments_df.copy()
                    decision_points_df_copy = decision_points_df.copy()
                    
                    # Convert trajectory columns to string to ensure compatibility
                    if &#39;trajectory&#39; in assignments_df_copy.columns:
                        assignments_df_copy[&#39;trajectory&#39;] = assignments_df_copy[&#39;trajectory&#39;].astype(str)
                    if &#39;trajectory&#39; in decision_points_df_copy.columns:
                        decision_points_df_copy[&#39;trajectory&#39;] = decision_points_df_copy[&#39;trajectory&#39;].astype(str)
                    
                    try:
                        merged_df = assignments_df_copy.merge(decision_points_df_copy, on=&#39;trajectory&#39;, how=&#39;inner&#39;)
                        branch_points = merged_df[merged_df[&#39;branch&#39;] == i]
                        
                        if len(branch_points) &gt; 0:
                            # Calculate average direction from junction center to actual decision points
                            intercept_x = branch_points[&#39;intercept_x&#39;].values
                            intercept_z = branch_points[&#39;intercept_z&#39;].values
                            
                            # Calculate direction vectors from junction center to decision points
                            dx = intercept_x - junction.cx
                            dz = intercept_z - junction.cz
                            
                            # Calculate average direction (normalize to unit vector)
                            avg_dx = np.mean(dx)
                            avg_dz = np.mean(dz)
                            norm = np.sqrt(avg_dx**2 + avg_dz**2)
                            
                            if norm &gt; 0:
                                branch_direction = np.array([avg_dx/norm, avg_dz/norm])
                            else:
                                # Fallback to cluster center if no valid direction
                                branch_direction = center
                        else:
                            # Fallback to cluster center if no decision points
                            branch_direction = center
                    except Exception:
                        # Fallback to cluster center if merge fails
                        branch_direction = center
                else:
                    # Use cluster center if no decision points available
                    branch_direction = center
                
                # Plot branch marker using calculated direction
                branch_x = junction.cx + r_outer * branch_direction[0]
                branch_z = junction.cz + r_outer * branch_direction[1]
                
                # Plot triangular markers for this branch
                ax.scatter([branch_x], [branch_z], c=color, s=100, marker=marker, 
                          label=f&#39;branch {i} (radial) - {branch_count} trajectories&#39;, 
                          edgecolors=&#39;black&#39;, linewidth=1)
                
                # Draw dashed line from branch to junction center
                ax.plot([branch_x, junction.cx], [branch_z, junction.cz], 
                       color=color, linestyle=&#39;--&#39;, linewidth=2, alpha=0.7)
        
        # Plot all individual intercept points using ACTUAL decision point coordinates
        if decision_points_df is not None and len(decision_points_df) &gt; 0:
            # Ensure trajectory columns have consistent data types for merging
            assignments_df_copy = assignments_df.copy()
            decision_points_df_copy = decision_points_df.copy()
            
            # Convert trajectory columns to string to ensure compatibility
            if &#39;trajectory&#39; in assignments_df_copy.columns:
                assignments_df_copy[&#39;trajectory&#39;] = assignments_df_copy[&#39;trajectory&#39;].astype(str)
            if &#39;trajectory&#39; in decision_points_df_copy.columns:
                decision_points_df_copy[&#39;trajectory&#39;] = decision_points_df_copy[&#39;trajectory&#39;].astype(str)
            
            # Merge decision points with assignments to get branch information
            try:
                merged_df = assignments_df_copy.merge(decision_points_df_copy, on=&#39;trajectory&#39;, how=&#39;inner&#39;)
            except Exception as e:
                # If merge still fails, try alternative approach
                print(f&#34;Warning: Merge failed with error: {e}&#34;)
                print(f&#34;Assignments trajectory type: {assignments_df_copy[&#39;trajectory&#39;].dtype}&#34;)
                print(f&#34;Decision points trajectory type: {decision_points_df_copy[&#39;trajectory&#39;].dtype}&#34;)
                print(f&#34;Sample assignments trajectory values: {assignments_df_copy[&#39;trajectory&#39;].head().tolist()}&#34;)
                print(f&#34;Sample decision points trajectory values: {decision_points_df_copy[&#39;trajectory&#39;].head().tolist()}&#34;)
                # Fall back to theoretical positions
                merged_df = None
            
            if merged_df is not None and len(merged_df) &gt; 0:
                for i, center in enumerate(centers):
                    color = colors[i % len(colors)]
                    branch_assignments = merged_df[merged_df[&#39;branch&#39;] == i]
                    
                    if len(branch_assignments) &gt; 0:
                        # Plot actual decision intercept points
                        intercept_x = branch_assignments[&#39;intercept_x&#39;].values
                        intercept_z = branch_assignments[&#39;intercept_z&#39;].values
                        
                        ax.scatter(intercept_x, intercept_z, 
                                 c=color, s=40, alpha=0.8, marker=&#39;o&#39;, 
                                 edgecolors=&#39;white&#39;, linewidth=1.5,
                                 label=f&#39;branch {i} (actual) - {len(branch_assignments)} trajectories&#39;)
            else:
                # Fall back to theoretical positions if merge failed or no data
                print(&#34;Falling back to theoretical positions due to merge issues&#34;)
                for i, center in enumerate(centers):
                    color = colors[i % len(colors)]
                    branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
                    
                    if len(branch_assignments) &gt; 0:
                        # Calculate base intercept point position using unit vector directions
                        base_x = junction.cx + r_outer * center[0]
                        base_z = junction.cz + r_outer * center[1]
                        
                        # Plot theoretical positions (larger, more visible)
                        ax.scatter([base_x], [base_z], 
                                 c=color, s=80, alpha=0.9, marker=&#39;s&#39;, 
                                 edgecolors=&#39;black&#39;, linewidth=2,
                                 label=f&#39;branch {i} (theoretical) - {len(branch_assignments)} trajectories&#39;)
        else:
            # Fallback: Plot theoretical positions if no decision points data available
            for i, center in enumerate(centers):
                color = colors[i % len(colors)]
                branch_assignments = assignments_df[assignments_df[&#39;branch&#39;] == i]
                
                if len(branch_assignments) &gt; 0:
                    # Calculate base intercept point position using unit vector directions
                    base_x = junction.cx + r_outer * center[0]
                    base_z = junction.cz + r_outer * center[1]
                    
                    # Plot theoretical positions (larger, more visible)
                    ax.scatter([base_x], [base_z], 
                             c=color, s=80, alpha=0.9, marker=&#39;s&#39;, 
                             edgecolors=&#39;black&#39;, linewidth=2,
                             label=f&#39;branch {i} (theoretical) - {len(branch_assignments)} trajectories&#39;)
        
        # Add branch statistics text box
        stats_text = &#34;Branch Statistics:\n&#34;
        for i in range(len(centers)):
            count = branch_counts.get(i, 0)
            percentage = (count / total_trajectories * 100) if total_trajectories &gt; 0 else 0
            stats_text += f&#34;Branch {i}: {count} ({percentage:.1f}%)\n&#34;
        
        # Position text box in upper left corner
        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, fontsize=10,
                verticalalignment=&#39;top&#39;, bbox=dict(boxstyle=&#39;round&#39;, facecolor=&#39;white&#39;, alpha=0.8))
    
    ax.set_aspect(&#39;equal&#39;)
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Z&#39;)
    ax.set_title(&#39;Decision intercepts by branch&#39;)
    
    # Move legend outside the plot area to the right
    ax.legend(bbox_to_anchor=(1.05, 1), loc=&#39;upper left&#39;)
    ax.grid(True, alpha=0.3)
    
    # Add mini-map showing overall view
    if all_junctions is not None and len(all_junctions) &gt; 1:
        ax_mini = fig.add_subplot(gs[2])
        
        # Plot all trajectories in mini-map
        for tr in trajectories:
            ax_mini.plot(tr.x, tr.z, color=&#34;0.7&#34;, linewidth=0.3, alpha=0.2)
        
        # Plot all junctions
        for i, junc in enumerate(all_junctions):
            if i == junction_number:
                # Highlight current junction
                circle = plt.Circle((junc.cx, junc.cz), junc.r, fill=False, 
                                  color=&#39;red&#39;, linewidth=3, label=f&#39;Junction {i} (Current)&#39;)
                ax_mini.add_patch(circle)
                ax_mini.scatter([junc.cx], [junc.cz], c=&#39;red&#39;, s=50, marker=&#39;o&#39;, zorder=5)
            else:
                # Other junctions
                circle = plt.Circle((junc.cx, junc.cz), junc.r, fill=False, 
                                  color=&#39;gray&#39;, linewidth=1, alpha=0.7)
                ax_mini.add_patch(circle)
                ax_mini.scatter([junc.cx], [junc.cz], c=&#39;gray&#39;, s=30, marker=&#39;o&#39;, alpha=0.7)
        
        # Add rectangle showing the area shown in main plot
        main_xlim = ax.get_xlim()
        main_ylim = ax.get_ylim()
        rect = plt.Rectangle((main_xlim[0], main_ylim[0]), 
                           main_xlim[1] - main_xlim[0], 
                           main_ylim[1] - main_ylim[0],
                           fill=False, color=&#39;blue&#39;, linewidth=2, linestyle=&#39;--&#39;, alpha=0.8)
        ax_mini.add_patch(rect)
        
        ax_mini.set_aspect(&#39;equal&#39;)
        ax_mini.set_xlabel(&#39;X (Overall View)&#39;)
        ax_mini.set_ylabel(&#39;Z (Overall View)&#39;)
        ax_mini.set_title(&#39;Mini-map: All Junctions and Trajectories&#39;)
        ax_mini.grid(True, alpha=0.3)
        
        # Set reasonable limits for mini-map
        all_x = [tr.x for tr in trajectories]
        all_z = [tr.z for tr in trajectories]
        if all_x and all_z:
            x_min, x_max = min([min(x) for x in all_x]), max([max(x) for x in all_x])
            z_min, z_max = min([min(z) for z in all_z]), max([max(z) for z in all_z])
            margin = 50
            ax_mini.set_xlim(x_min - margin, x_max + margin)
            ax_mini.set_ylim(z_min - margin, z_max + margin)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#39;tight&#39;)
    plt.close()</code></pre>
</details>
</dd>
<dt id="verta.verta_plotting.plot_flow_graph_map"><code class="name flex">
<span>def <span class="ident">plot_flow_graph_map</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>], chain_df: pandas.core.frame.DataFrame, junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>], *, r_outer_list: Optional[List[float]] = None, out_path: str = 'Flow_Graph_Map.png', junction_names: Optional[List[str]] = None, show_junction_names: bool = True, min_flow_threshold: float = 0.001, arrow_scale: float = 1.0, cached_sequences: Optional[Dict[int, List[int]]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Map-style flow graph showing flow percentages between junctions.</p>
<p>Shows arrows between junctions indicating what percentage of trajectories go directly from each source to each destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of Trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with trajectory assignments for each junction</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of Circle objects representing junctions</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>List of outer radii for each junction</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Path to save the plot</dd>
<dt><strong><code>junction_names</code></strong></dt>
<dd>Optional list of names for junctions</dd>
<dt><strong><code>show_junction_names</code></strong></dt>
<dd>Whether to show junction names</dd>
<dt><strong><code>min_flow_threshold</code></strong></dt>
<dd>Minimum flow percentage to show arrow (0.001 = 0.1%)</dd>
<dt><strong><code>arrow_scale</code></strong></dt>
<dd>Scale factor for arrow sizes</dd>
<dt><strong><code>cached_sequences</code></strong></dt>
<dd>Optional pre-computed node sequences for trajectories</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_flow_graph_map(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    *,
    r_outer_list: Optional[List[float]] = None,
    out_path: str = &#34;Flow_Graph_Map.png&#34;,
    junction_names: Optional[List[str]] = None,
    show_junction_names: bool = True,
    min_flow_threshold: float = 0.001,
    arrow_scale: float = 1.0,
    cached_sequences: Optional[Dict[int, List[int]]] = None,
) -&gt; None:
    &#34;&#34;&#34;Map-style flow graph showing flow percentages between junctions.
    
    Shows arrows between junctions indicating what percentage of trajectories go directly from each source to each destination.
    
    Args:
        trajectories: List of Trajectory objects
        chain_df: DataFrame with trajectory assignments for each junction
        junctions: List of Circle objects representing junctions
        r_outer_list: List of outer radii for each junction
        out_path: Path to save the plot
        junction_names: Optional list of names for junctions
        show_junction_names: Whether to show junction names
        min_flow_threshold: Minimum flow percentage to show arrow (0.001 = 0.1%)
        arrow_scale: Scale factor for arrow sizes
        cached_sequences: Optional pre-computed node sequences for trajectories
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch
    
    if r_outer_list is None:
        r_outer_list = [None] * len(junctions)
    
    # Generate default junction names if not provided
    if junction_names is None:
        junction_names = [f&#34;J{i}&#34; for i in range(len(junctions))]
    elif len(junction_names) != len(junctions):
        junction_names = junction_names[:len(junctions)]
        while len(junction_names) &lt; len(junctions):
            junction_names.append(f&#34;J{len(junction_names)}&#34;)
    
    # Calculate overall flow matrix (total percentages across all trajectories)
    flow_matrix = _calculate_overall_flow_matrix(trajectories, chain_df, junctions, r_outer_list, cached_sequences)
    
    # Create the plot
    plt.figure(figsize=(12, 10))
    ax = plt.gca()
    
    # Plot all trajectories in light gray background
    for tr in trajectories:
        ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.8, alpha=0.3, zorder=0)
    
    # Draw junction circles
    theta = np.linspace(0, 2*np.pi, 512)
    for i, (junc, r_out) in enumerate(zip(junctions, r_outer_list)):
        # Inner circle
        jr_x = junc.cx + junc.r*np.cos(theta)
        jr_z = junc.cz + junc.r*np.sin(theta)
        ax.plot(jr_x, jr_z, color=&#34;black&#34;, linewidth=1.5, zorder=2)
        
        # Outer circle if provided
        if r_out is not None and float(r_out) &gt; float(junc.r):
            ox = junc.cx + float(r_out)*np.cos(theta)
            oz = junc.cz + float(r_out)*np.sin(theta)
            ax.plot(ox, oz, color=&#34;orange&#34;, linewidth=1.0, alpha=0.7, zorder=2)
        
        # Junction center
        ax.scatter([junc.cx], [junc.cz], color=&#34;black&#34;, s=30, zorder=3)
        
        # Junction name label
        if show_junction_names:
            ax.annotate(junction_names[i], 
                       (junc.cx, junc.cz), 
                       xytext=(8, 8), 
                       textcoords=&#39;offset points&#39;,
                       fontsize=12, 
                       fontweight=&#39;bold&#39;,
                       color=&#39;red&#39;,
                       bbox=dict(boxstyle=&#39;round,pad=0.4&#39;, 
                                facecolor=&#39;white&#39;, 
                                edgecolor=&#39;red&#39;,
                                alpha=0.9),
                       zorder=5)
    
    # Draw flow arrows
    max_flow = np.max(flow_matrix) if flow_matrix.size &gt; 0 else 1.0
    min_arrow_size = 15
    max_arrow_size = 100
    
    # Create node positions for arrow drawing
    node_positions = []
    node_names = []
    
    # Junction positions
    for i, junc in enumerate(junctions):
        node_positions.append((junc.cx, junc.cz))
        node_names.append(f&#34;J{i}&#34;)
    
    for i in range(len(junctions)):
        for j in range(len(junctions)):
            if i != j and flow_matrix[i, j] &gt;= min_flow_threshold:
                # Calculate arrow properties
                flow_percentage = flow_matrix[i, j]
                arrow_size = min_arrow_size + (max_arrow_size - min_arrow_size) * (flow_percentage / max_flow)
                arrow_size *= arrow_scale
                
                # Arrow color based on flow intensity
                color_intensity = flow_percentage / max_flow
                arrow_color = plt.cm.Blues(0.3 + 0.7 * color_intensity)
                
                # Calculate start and end points with appropriate offsets
                start_junc = junctions[i]
                end_junc = junctions[j]
                
                # Calculate arrow direction
                dx = end_junc.cx - start_junc.cx
                dy = end_junc.cz - start_junc.cz
                distance = np.sqrt(dx**2 + dy**2)
                
                if distance &gt; 0:
                    # Normalize direction
                    dx_norm = dx / distance
                    dy_norm = dy / distance
                    
                    # Calculate start and end points
                    start_x = start_junc.cx + dx_norm * start_junc.r
                    start_y = start_junc.cz + dy_norm * start_junc.r
                    end_x = end_junc.cx - dx_norm * end_junc.r
                    end_y = end_junc.cz - dy_norm * end_junc.r
                    
                    # Create arrow
                    arrow = FancyArrowPatch(
                        (start_x, start_y), (end_x, end_y),
                        arrowstyle=&#39;-&gt;&#39;, 
                        mutation_scale=arrow_size,
                        color=arrow_color,
                        linewidth=max(1, int(2 + 3 * flow_percentage / max_flow)),
                        alpha=0.8,
                        zorder=4
                    )
                    ax.add_patch(arrow)
                    
                    # Add flow percentage label
                    mid_x = (start_x + end_x) / 2
                    mid_y = (start_y + end_y) / 2
                    
                    # Offset label slightly to avoid overlap
                    label_offset_x = -dy_norm * 10
                    label_offset_y = dx_norm * 10
                    
                    ax.annotate(f&#39;{flow_percentage:.1%}&#39;, 
                               (mid_x + label_offset_x, mid_y + label_offset_y),
                               ha=&#39;center&#39;, va=&#39;center&#39;,
                               fontsize=9,
                               fontweight=&#39;bold&#39;,
                               color=&#39;darkblue&#39;,
                               bbox=dict(boxstyle=&#39;round,pad=0.3&#39;, 
                                        facecolor=&#39;white&#39;, 
                                        edgecolor=&#39;darkblue&#39;,
                                        alpha=0.9),
                               zorder=6)
    
    # Set equal aspect and labels
    ax.set_aspect(&#34;equal&#34;)
    ax.set_xlabel(&#34;X&#34;)
    ax.set_ylabel(&#34;Z&#34;)
    ax.set_title(&#34;Flow Graph Map&#34;, fontsize=14, fontweight=&#39;bold&#39;)
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], color=&#39;black&#39;, linewidth=2, label=&#39;Junction&#39;),
        plt.Line2D([0], [0], color=&#39;orange&#39;, linewidth=2, label=&#39;Analysis Radius&#39;),
        plt.Line2D([0], [0], color=&#39;blue&#39;, linewidth=2, label=&#39;Flow Direction (%)&#39;),
        plt.Line2D([0], [0], color=&#39;0.8&#39;, linewidth=1, alpha=0.3, label=&#39;Trajectories&#39;)
    ]
    
    ax.legend(handles=legend_elements, loc=&#39;upper right&#39;)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.close()</code></pre>
</details>
</dd>
<dt id="verta.verta_plotting.plot_per_junction_flow_graph"><code class="name flex">
<span>def <span class="ident">plot_per_junction_flow_graph</span></span>(<span>trajectories: List[<a title="verta.verta_data_loader.Trajectory" href="verta_data_loader.html#verta.verta_data_loader.Trajectory">Trajectory</a>], chain_df: pandas.core.frame.DataFrame, junctions: List[<a title="verta.verta_geometry.Circle" href="verta_geometry.html#verta.verta_geometry.Circle">Circle</a>], *, r_outer_list: Optional[List[float]] = None, out_path: str = 'Per_Junction_Flow_Graph.png', junction_names: Optional[List[str]] = None, show_junction_names: bool = True, min_flow_threshold: float = 0.001, arrow_scale: float = 1.0, cached_sequences: Optional[Dict[int, List[int]]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Map-style flow graph showing percentages per junction including zones.</p>
<p>Shows arrows between junctions and zones indicating what percentage of trajectories leaving each junction go directly to each destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectories</code></strong></dt>
<dd>List of Trajectory objects</dd>
<dt><strong><code>chain_df</code></strong></dt>
<dd>DataFrame with trajectory assignments for each junction</dd>
<dt><strong><code>junctions</code></strong></dt>
<dd>List of Circle objects representing junctions</dd>
<dt><strong><code>r_outer_list</code></strong></dt>
<dd>List of outer radii for each junction</dd>
<dt><strong><code>out_path</code></strong></dt>
<dd>Path to save the plot</dd>
<dt><strong><code>junction_names</code></strong></dt>
<dd>Optional list of names for junctions</dd>
<dt><strong><code>show_junction_names</code></strong></dt>
<dd>Whether to show junction names</dd>
<dt><strong><code>min_flow_threshold</code></strong></dt>
<dd>Minimum flow percentage to show arrow (0.001 = 0.1%)</dd>
<dt><strong><code>arrow_scale</code></strong></dt>
<dd>Scale factor for arrow sizes</dd>
<dt><strong><code>start_zones</code></strong></dt>
<dd>Optional list of start zone definitions</dd>
<dt><strong><code>end_zones</code></strong></dt>
<dd>Optional list of end zone definitions</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_per_junction_flow_graph(
    trajectories: List[Trajectory],
    chain_df: pd.DataFrame,
    junctions: List[Circle],
    *,
    r_outer_list: Optional[List[float]] = None,
    out_path: str = &#34;Per_Junction_Flow_Graph.png&#34;,
    junction_names: Optional[List[str]] = None,
    show_junction_names: bool = True,
    min_flow_threshold: float = 0.001,  # Reduced from 0.01 to show flows as low as 0.1%
    arrow_scale: float = 1.0,
    cached_sequences: Optional[Dict[int, List[int]]] = None,
) -&gt; None:
    &#34;&#34;&#34;Map-style flow graph showing percentages per junction including zones.
    
    Shows arrows between junctions and zones indicating what percentage of trajectories leaving each junction go directly to each destination.
    
    Args:
        trajectories: List of Trajectory objects
        chain_df: DataFrame with trajectory assignments for each junction
        junctions: List of Circle objects representing junctions
        r_outer_list: List of outer radii for each junction
        out_path: Path to save the plot
        junction_names: Optional list of names for junctions
        show_junction_names: Whether to show junction names
        min_flow_threshold: Minimum flow percentage to show arrow (0.001 = 0.1%)
        arrow_scale: Scale factor for arrow sizes
        start_zones: Optional list of start zone definitions
        end_zones: Optional list of end zone definitions
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch
    
    if r_outer_list is None:
        r_outer_list = [None] * len(junctions)
    
    # Generate default junction names if not provided
    if junction_names is None:
        junction_names = [f&#34;J{i}&#34; for i in range(len(junctions))]
    elif len(junction_names) != len(junctions):
        junction_names = junction_names[:len(junctions)]
        while len(junction_names) &lt; len(junctions):
            junction_names.append(f&#34;J{len(junction_names)}&#34;)
    
    # Calculate per-junction flows
    flow_matrix = _calculate_per_junction_flows(trajectories, chain_df, junctions, r_outer_list, cached_sequences)
    
    # Create the plot
    plt.figure(figsize=(12, 10))
    ax = plt.gca()
    
    # Plot all trajectories in light gray background
    for tr in trajectories:
        ax.plot(tr.x, tr.z, color=&#34;0.8&#34;, linewidth=0.8, alpha=0.3, zorder=0)
    
    # Draw junction circles
    theta = np.linspace(0, 2*np.pi, 512)
    for i, (junc, r_out) in enumerate(zip(junctions, r_outer_list)):
        # Inner circle
        jr_x = junc.cx + junc.r*np.cos(theta)
        jr_z = junc.cz + junc.r*np.sin(theta)
        ax.plot(jr_x, jr_z, color=&#34;black&#34;, linewidth=1.5, zorder=2)
        
        # Outer circle if provided
        if r_out is not None and float(r_out) &gt; float(junc.r):
            ox = junc.cx + float(r_out)*np.cos(theta)
            oz = junc.cz + float(r_out)*np.sin(theta)
            ax.plot(ox, oz, color=&#34;orange&#34;, linewidth=1.0, alpha=0.7, zorder=2)
        
        # Junction center
        ax.scatter([junc.cx], [junc.cz], color=&#34;black&#34;, s=30, zorder=3)
        
        # Junction name label
        if show_junction_names:
            ax.annotate(junction_names[i], 
                       (junc.cx, junc.cz), 
                       xytext=(8, 8), 
                       textcoords=&#39;offset points&#39;,
                       fontsize=12, 
                       fontweight=&#39;bold&#39;,
                       color=&#39;red&#39;,
                       bbox=dict(boxstyle=&#39;round,pad=0.4&#39;, 
                                facecolor=&#39;white&#39;, 
                                edgecolor=&#39;red&#39;,
                                alpha=0.9),
                       zorder=5)
    
    # Draw flow arrows with improved labeling
    max_flow = np.max(flow_matrix) if flow_matrix.size &gt; 0 else 1.0
    min_arrow_size = 15
    max_arrow_size = 100
    
    print(f&#34;DEBUG: Per-junction flow matrix:\n{flow_matrix}&#34;)
    print(f&#34;DEBUG: Max flow: {max_flow}&#34;)
    
    # Create node positions for arrow drawing
    node_positions = []
    node_names = []
    
    # Junction positions
    for i, junc in enumerate(junctions):
        node_positions.append((junc.cx, junc.cz))
        node_names.append(f&#34;J{i}&#34;)
    
    for i in range(len(junctions)):
        for j in range(len(junctions)):
            if i != j and flow_matrix[i, j] &gt;= min_flow_threshold:
                # Calculate arrow properties
                flow_percentage = flow_matrix[i, j]
                arrow_size = min_arrow_size + (max_arrow_size - min_arrow_size) * (flow_percentage / max_flow)
                arrow_size *= arrow_scale
                
                # Arrow color based on flow intensity
                color_intensity = flow_percentage / max_flow
                arrow_color = plt.cm.Greens(0.3 + 0.7 * color_intensity)  # Use green for per-junction flows
                
                # Calculate start and end points with appropriate offsets
                start_junc = junctions[i]
                end_junc = junctions[j]
                
                # Calculate arrow direction
                dx = end_junc.cx - start_junc.cx
                dy = end_junc.cz - start_junc.cz
                distance = np.sqrt(dx**2 + dy**2)
                
                if distance &gt; 0:
                    # Normalize direction
                    dx_norm = dx / distance
                    dy_norm = dy / distance
                    
                    # Calculate start and end points
                    start_x = start_junc.cx + dx_norm * start_junc.r
                    start_y = start_junc.cz + dy_norm * start_junc.r
                    end_x = end_junc.cx - dx_norm * end_junc.r
                    end_y = end_junc.cz - dy_norm * end_junc.r
                    
                    # Create arrow
                    arrow = FancyArrowPatch(
                        (start_x, start_y), (end_x, end_y),
                        arrowstyle=&#39;-&gt;&#39;, 
                        mutation_scale=arrow_size,
                        color=arrow_color,
                        linewidth=max(1, int(2 + 3 * flow_percentage / max_flow)),
                        alpha=0.8,
                        zorder=4
                    )
                    ax.add_patch(arrow)
                    
                    # Add flow percentage label with better positioning
                    mid_x = (start_x + end_x) / 2
                    mid_y = (start_y + end_y) / 2
                    
                    # Offset label slightly to avoid overlap
                    label_offset_x = -dy_norm * 10  # Perpendicular offset
                    label_offset_y = dx_norm * 10
                    
                    ax.annotate(f&#39;{flow_percentage:.1%}&#39;, 
                               (mid_x + label_offset_x, mid_y + label_offset_y),
                               ha=&#39;center&#39;, va=&#39;center&#39;,
                               fontsize=9,
                               fontweight=&#39;bold&#39;,
                               color=&#39;darkgreen&#39;,
                               bbox=dict(boxstyle=&#39;round,pad=0.3&#39;, 
                                        facecolor=&#39;white&#39;, 
                                        edgecolor=&#39;darkgreen&#39;,
                                        alpha=0.9),
                               zorder=6)
    
    # Set equal aspect and labels
    ax.set_aspect(&#34;equal&#34;)
    ax.set_xlabel(&#34;X&#34;)
    ax.set_ylabel(&#34;Z&#34;)
    ax.set_title(&#34;Flow Graph: Per-Junction Percentages&#34;, fontsize=14, fontweight=&#39;bold&#39;)
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], color=&#39;black&#39;, linewidth=2, label=&#39;Junction&#39;),
        plt.Line2D([0], [0], color=&#39;orange&#39;, linewidth=2, label=&#39;Decision Radius&#39;),
        plt.Line2D([0], [0], color=&#39;green&#39;, linewidth=2, label=&#39;Flow Direction (per-junction %)&#39;),
        plt.Line2D([0], [0], color=&#39;0.8&#39;, linewidth=1, alpha=0.3, label=&#39;Trajectories&#39;)
    ]
    
    ax.legend(handles=legend_elements, loc=&#39;upper right&#39;)
    
    plt.tight_layout()
    plt.savefig(out_path, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="verta.verta_plotting.PlotConfig"><code class="flex name class">
<span>class <span class="ident">PlotConfig</span></span>
<span>(</span><span>dpi: int = 100, figsize: Tuple[float, float] = (12, 8), tight_layout: bool = True, branch_colors: Tuple[str, ...] = ('#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'), fontsize: int = 12, title_fontsize: int = 14, label_fontsize: int = 12, legend_fontsize: int = 10, arrow_scale: float = 0.8, arrow_width: float = 0.002, arrow_head_width: float = 0.01, arrow_head_length: float = 0.01, junction_alpha: float = 0.3, junction_edge_width: float = 2.0, trajectory_alpha: float = 0.6, trajectory_linewidth: float = 1.0, grid_alpha: float = 0.3, grid_linewidth: float = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Centralized plot configuration settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class PlotConfig:
    &#34;&#34;&#34;Centralized plot configuration settings.&#34;&#34;&#34;
    
    # Figure settings
    dpi: int = 100
    figsize: Tuple[float, float] = (12, 8)
    tight_layout: bool = True
    
    # Color settings - colors are used again if more than 10 branches
    branch_colors: Tuple[str, ...] = (&#39;#1f77b4&#39;, &#39;#ff7f0e&#39;, &#39;#2ca02c&#39;, &#39;#d62728&#39;, &#39;#9467bd&#39;, &#39;#8c564b&#39;, &#39;#e377c2&#39;, &#39;#7f7f7f&#39;, &#39;#bcbd22&#39;, &#39;#17becf&#39;)
    
    # Font settings
    fontsize: int = 12
    title_fontsize: int = 14
    label_fontsize: int = 12
    legend_fontsize: int = 10
    
    # Arrow settings
    arrow_scale: float = 0.8
    arrow_width: float = 0.002
    arrow_head_width: float = 0.01
    arrow_head_length: float = 0.01
    
    # Junction settings
    junction_alpha: float = 0.3
    junction_edge_width: float = 2.0
    
    # Trajectory settings
    trajectory_alpha: float = 0.6
    trajectory_linewidth: float = 1.0
    
    # Grid settings
    grid_alpha: float = 0.3
    grid_linewidth: float = 0.5
    
    def apply_to_figure(self, fig) -&gt; None:
        &#34;&#34;&#34;Apply configuration to a matplotlib figure.&#34;&#34;&#34;
        if self.tight_layout:
            fig.tight_layout()
    
    def get_branch_color(self, branch_idx: int) -&gt; str:
        &#34;&#34;&#34;Get color for a branch index.&#34;&#34;&#34;
        return self.branch_colors[branch_idx % len(self.branch_colors)]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="verta.verta_plotting.PlotConfig.arrow_head_length"><code class="name">var <span class="ident">arrow_head_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.arrow_head_width"><code class="name">var <span class="ident">arrow_head_width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.arrow_scale"><code class="name">var <span class="ident">arrow_scale</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.arrow_width"><code class="name">var <span class="ident">arrow_width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.branch_colors"><code class="name">var <span class="ident">branch_colors</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.dpi"><code class="name">var <span class="ident">dpi</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.figsize"><code class="name">var <span class="ident">figsize</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.fontsize"><code class="name">var <span class="ident">fontsize</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.grid_alpha"><code class="name">var <span class="ident">grid_alpha</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.grid_linewidth"><code class="name">var <span class="ident">grid_linewidth</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.junction_alpha"><code class="name">var <span class="ident">junction_alpha</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.junction_edge_width"><code class="name">var <span class="ident">junction_edge_width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.label_fontsize"><code class="name">var <span class="ident">label_fontsize</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.legend_fontsize"><code class="name">var <span class="ident">legend_fontsize</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.tight_layout"><code class="name">var <span class="ident">tight_layout</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.title_fontsize"><code class="name">var <span class="ident">title_fontsize</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.trajectory_alpha"><code class="name">var <span class="ident">trajectory_alpha</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="verta.verta_plotting.PlotConfig.trajectory_linewidth"><code class="name">var <span class="ident">trajectory_linewidth</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="verta.verta_plotting.PlotConfig.apply_to_figure"><code class="name flex">
<span>def <span class="ident">apply_to_figure</span></span>(<span>self, fig) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Apply configuration to a matplotlib figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_to_figure(self, fig) -&gt; None:
    &#34;&#34;&#34;Apply configuration to a matplotlib figure.&#34;&#34;&#34;
    if self.tight_layout:
        fig.tight_layout()</code></pre>
</details>
</dd>
<dt id="verta.verta_plotting.PlotConfig.get_branch_color"><code class="name flex">
<span>def <span class="ident">get_branch_color</span></span>(<span>self, branch_idx: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get color for a branch index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_branch_color(self, branch_idx: int) -&gt; str:
    &#34;&#34;&#34;Get color for a branch index.&#34;&#34;&#34;
    return self.branch_colors[branch_idx % len(self.branch_colors)]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="verta" href="index.html">verta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="verta.verta_plotting.plot_chain_overview" href="#verta.verta_plotting.plot_chain_overview">plot_chain_overview</a></code></li>
<li><code><a title="verta.verta_plotting.plot_chain_small_multiples" href="#verta.verta_plotting.plot_chain_small_multiples">plot_chain_small_multiples</a></code></li>
<li><code><a title="verta.verta_plotting.plot_decision_intercepts" href="#verta.verta_plotting.plot_decision_intercepts">plot_decision_intercepts</a></code></li>
<li><code><a title="verta.verta_plotting.plot_flow_graph_map" href="#verta.verta_plotting.plot_flow_graph_map">plot_flow_graph_map</a></code></li>
<li><code><a title="verta.verta_plotting.plot_per_junction_flow_graph" href="#verta.verta_plotting.plot_per_junction_flow_graph">plot_per_junction_flow_graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="verta.verta_plotting.PlotConfig" href="#verta.verta_plotting.PlotConfig">PlotConfig</a></code></h4>
<ul class="">
<li><code><a title="verta.verta_plotting.PlotConfig.apply_to_figure" href="#verta.verta_plotting.PlotConfig.apply_to_figure">apply_to_figure</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_head_length" href="#verta.verta_plotting.PlotConfig.arrow_head_length">arrow_head_length</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_head_width" href="#verta.verta_plotting.PlotConfig.arrow_head_width">arrow_head_width</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_scale" href="#verta.verta_plotting.PlotConfig.arrow_scale">arrow_scale</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.arrow_width" href="#verta.verta_plotting.PlotConfig.arrow_width">arrow_width</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.branch_colors" href="#verta.verta_plotting.PlotConfig.branch_colors">branch_colors</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.dpi" href="#verta.verta_plotting.PlotConfig.dpi">dpi</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.figsize" href="#verta.verta_plotting.PlotConfig.figsize">figsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.fontsize" href="#verta.verta_plotting.PlotConfig.fontsize">fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.get_branch_color" href="#verta.verta_plotting.PlotConfig.get_branch_color">get_branch_color</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.grid_alpha" href="#verta.verta_plotting.PlotConfig.grid_alpha">grid_alpha</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.grid_linewidth" href="#verta.verta_plotting.PlotConfig.grid_linewidth">grid_linewidth</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.junction_alpha" href="#verta.verta_plotting.PlotConfig.junction_alpha">junction_alpha</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.junction_edge_width" href="#verta.verta_plotting.PlotConfig.junction_edge_width">junction_edge_width</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.label_fontsize" href="#verta.verta_plotting.PlotConfig.label_fontsize">label_fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.legend_fontsize" href="#verta.verta_plotting.PlotConfig.legend_fontsize">legend_fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.tight_layout" href="#verta.verta_plotting.PlotConfig.tight_layout">tight_layout</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.title_fontsize" href="#verta.verta_plotting.PlotConfig.title_fontsize">title_fontsize</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.trajectory_alpha" href="#verta.verta_plotting.PlotConfig.trajectory_alpha">trajectory_alpha</a></code></li>
<li><code><a title="verta.verta_plotting.PlotConfig.trajectory_linewidth" href="#verta.verta_plotting.PlotConfig.trajectory_linewidth">trajectory_linewidth</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>